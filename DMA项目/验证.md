![[Pasted image 20250727000855.png]]
## 1、**$finish at simulation time                    0**
**仿真“ 0 ps 就 $finish ”**
UVM 根在 time 0 没看到objection，于是直接结束
但 **run_phase 本身根本没机会执行**——因为 UVM 根在 **run_phase 开始之前** 就检查了一次 _还有没有 objection_。如果没有，它立刻 `$finish`。
## 2、第一组地址为0的数据和地址没进来
![[Pasted image 20250807154848.png]]
driver直接写接口信号，不用clocking-block
clocking drv_cb @(posedge clk);
    default input #0  output #0;   **// ← skew #0 ≠ “立刻”，而是“在下一个时钟沿”**
    output awaddr, wdata, awvalid, wvalid;
endclocking
- `drv_cb.awvalid <= 1;` **不会立刻把 awvalid 变成 1**。  
    它会在 **下一次 posedge clk 的 Active region** 才真正驱动。
    
- 再执行 `@(posedge clk);` 进入下一拍；  
    第二句 `drv_cb.awvalid <= 0;` 又被排队到 **再下一个 posedge**。
    ![[Pasted image 20250807162022.png]]
