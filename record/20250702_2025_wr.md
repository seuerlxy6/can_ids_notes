# wr地址和循环

## 从波形能看出 3 个循环的嵌套层次：

| 计数器      | 变化速度   | 作用                               |
| -------- | ------ | -------------------------------- |
| `N_cnt`  | **最快** | 当前写的输出通道 index（1‥N）              |
| `ox_cnt` | 中等     | 当前行里第几个 **8-byte 列块**（0‥OUT_w-1） |
| `oy_cnt` | **最慢** | 当前输出行 index（0‥OUT_h-1）           |
![[Pasted image 20250702201325.png]]
### InOut-Buffer
┌─────────────┬─────────────┬─────────────┐
│ Bank0 (Byte)   │ Bank1 (Byte)   │ … Bank7         │   ← 8 个并行 Byte-wide BRAM
│ addr 0             │ addr 0            │                        │
│ addr 1             │ addr 1            │                        │
└─────────────┴─────────────┴─────────────┘
                 ▲
                 └─ **同一个 wr_addr** 连接到 8 个 bank

### 代码段落修改
    always @(posedge clk_cal or negedge rst_cal_n) // 循环2: ox_cnt
        if(!rst_cal_n || (or_cs==OR_FT_WT && or_ns==OR_CAL)) 
            ox_cnt <= 0;
        else if(n_write_loop_done) 
            ox_cnt <= (ox_cnt == **omap_addr_span_w** - 1) ? 0 : ox_cnt + 1;
直接让oxcnt是行数据的列块号，省去一次出发运算，逻辑上也更符合师兄的代码
## 计数器有问题
![[Pasted image 20250702203733.png]]


**Fix**

| 计数器      | 变化速度   | 作用                                                |
| -------- | ------ | ------------------------------------------------- |
| `N_cnt`  | **最快** | 当前写的输出通道 index（1‥N）                               |
| `ox_cnt` | 中等     | 当前行里第几个 **8*8-byte 列块**（0‥**omap_addr_span_w-1**） |
| `oy_cnt` | **最慢** | 当前输出行 index（0‥OUT_h-1）                            |
**Post-mortem**
