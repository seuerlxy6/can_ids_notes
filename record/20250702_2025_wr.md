# wr地址和循环

**Issue**
从波形能看出 3 个循环的嵌套层次：

| 计数器      | 变化速度   | 作用                               |
| -------- | ------ | -------------------------------- |
| `N_cnt`  | **最快** | 当前写的输出通道 index（1‥N）              |
| `ox_cnt` | 中等     | 当前行里第几个 **8-byte 列块**（0‥OUT_w-1） |
| `oy_cnt` | **最慢** | 当前输出行 index（0‥OUT_h-1）           |
![[Pasted image 20250702201325.png]]
InOut-Buffer
┌─────────────┬─────────────┬─────────────┐
│ Bank0 (Byte)   │ Bank1 (Byte)   │ … Bank7         │   ← 8 个并行 Byte-wide BRAM
│ addr 0             │ addr 0            │                        │
│ addr 1             │ addr 1            │                        │
└─────────────┴─────────────┴─────────────┘
                 ▲
                 └─ **同一个 wr_addr** 连接到 8 个 bank

**Hypothesis**
    always @(posedge clk_cal or negedge rst_cal_n) // 循环2: ox_cnt
        if(!rst_cal_n || (or_cs==OR_FT_WT && or_ns==OR_CAL)) 
            ox_cnt <= 0;
        else if(n_write_loop_done) 
            ox_cnt <= (ox_cnt == **omap_addr_span_w** - 1) ? 0 : ox_cnt + 1;
直接让oxcnt是行数据的列块号，省去一次出发运算，逻辑上也更符合师兄的代码

**Experiment**

**Fix**
|计数器|作用|何时 +1|取值范围|
|---|---|---|---|
|**`N_cnt`**|输出通道 m|每写完 1 列数据块（`Data_I_vld` 高）|1 … N|
|**`ox_cnt`**|输出列 x|当 **该通道**写完最后一列 (`n_write_loop_done`)|0 … OUT_w-1|
|**`oy_cnt`**|输出行 y|当 **该行**所有列写完 (`x_write_loop_done`)|0 … OUT_h-1|
**Post-mortem**
