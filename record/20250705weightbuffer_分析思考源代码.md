 每一层的权重数量
 为了减少在数据读取过程中花费的时间和访存功耗，本设计对数据存储方式进行了优化设计，提出了片上缓存、中间缓存、寄存器堆的三级存储方案。

其中根据权重数据和特征图数据总量用于判断缓存大小，其中根据设计，神经网络1.0版本的参数量权重数目和计算量如表所示，1KB用于缓存1024个数据，所以令特征图数据缓存为1KB×8，而权重数据为2KB×8

| 网络层   | 输入特征图    | 输出特征图    | 卷积核大小    | 参数量  | 运算量  |
| ----- | -------- | -------- | -------- | ---- | ---- |
| 卷积层1  | 64×64×3  | 32×32×8  | 3×3×3×8  | 224  | 230K |
| 卷积层2  | 32×32×8  | 16×16×32 | 3×3×3×32 | 2336 | 600K |
| 最大池化* | 16×16×32 | 3×3×32   | 0        | 0    | 10K  |
| 全连接层1 | 288×1    | 16×1     | 16×228×1 | 4624 | 5K   |
| 全连接层2 | 16×1     | 2×1      | 2×64×1   | 34   | ＜1K  |


| Layer   | WkW_k (B) | SkS_k / Bank (B) | 总占用 (B) | Padding (B) |
| ------- | --------- | ---------------- | ------- | ----------- |
| Conv1   | 224       | 32               | 256     | 32          |
| Conv2   | 2 336     | 304              | 2 432   | 96          |
| FC1     | 4 624     | 592              | 4 736   | 112         |
| FC2     | 34        | 16               | 128     | 94          |
| MaxPool | 0         | 0                | 0       | 0           |


|       | Bank0 | Bank1 | Bank2 | Bank3 | Bank4 | Bank5 | Bank6 | Bank7 |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| Conv1 | 32    | 32    | 32    | 32    | 32    | 32    | 32    | 32    |
| Conv2 | 304   | 304   | 304   | 304   | 304   | 304   | 304   | 304   |
| FC1   | 592   | 592   | 592   | 592   | 592   | 592   | 592   | 592   |
| FC2   | 48    | 48    | 48    | 48    | 48    | 48    | 48    | 48    |


2 个卷积层 + 2 个全连接层的所有权重都装进 **8 列并行的片上 Weight Buffer**，  
**每列（BANK） 1 KB 深、8 bit 宽的 BRAM 就够**  
也就是 8 × 1 KB ≈ 8 KB，总资源远低于一块 18-kbit (≈2.25 KB) BRAM 的 4 块。

---

## 1. 逐层权重数量

| 层                  | 公式 (不含 bias)   | 总 Byte   | 8 列均分 → 每列                        |
| ------------------ | -------------- | -------- | --------------------------------- |
| Conv-1             | 3 × 3 × 3 × 8  | **216**  | 216 / 8 ≈ 27                      |
| Conv-2             | 3 × 3 × 8 × 32 | **2304** | 2304 / 8 = 288                    |
| FC-1 (做成 1×1 conv) | 288 × 16       | **4608** | 4608 / 8 = 576                    |
| FC-2               | 16 × 2         | **32**   | 32 / 8 = 4                        |
| **合计 (一列)**        | —              | —        | **27 + 288 + 576 + 4 = 895 Byte** |

> - 已把 bias 忽略（加起来 < 0.1 KB，可与权重同列或另开寄存）。
>     
> - 卷积核 3×3 = 9 Byte；`N_tiles = N/8`，故每列分到 `K×M×N_tiles` 个权重。
>     
> - 全连接层权重按 **列优先** 顺序线性排到同一 Bank；  
>     不需 3×3 滑窗，读逻辑与卷积层一样，只是 `K=1`。
>     

---

## 2. 片上 Weight Buffer 需求

|指标|计算|结果|
|---|---|---|
|**每列深度**|向上取整到 2 的整数次幂：`ceil_pow2(895)`|**1024** Byte|
|**地址宽**|`log2(1024)=10`|10 bit|
|**总 BRAM**|`8 列 × 1 KB = 8 KB`|≈ 4 × 18k BRAM|

> - 用 Xilinx **True Dual-Port BRAM**：B 口写（如果还想在线更新），A 口只读。
>     
> - 若模型固定，可把 `we=0`，综合器会把 BRAM 优化成 ROM。
>     
> - 还留 15 % 余量（1024-895）= 129 Byte/列，可放 bias 或量化表。
>     

---

## 3. 地址与使能（保持你原设计）

```
wt_C?_addr  =  K_cnt + (M_cnt-1)*K  + (Nt_cnt-1)*K*M     // 每列地址公式
wt_C?_O_vld =  从 Mem_Ctrl 来的一拍脉冲                  // 9 拍/列/通道
```

- **写端**（如果保留）  
    `wt_I_vld` 连 B 口 `we_b`，`wt_I_addr` 连 B 口 `addr_b`。
    
- **读端**  
    `wt_C?_addr` → A 口 `addr_a`，  
    `wt_C?_O_vld | wt_C?_O_vld_d` → A 口 `en_a`，  
    读延迟 1 拍得到 `kernel_C?_O`。
    
- **列同步**：`wt_Ovld0` = `wt_C0_O_vld_d1`，再移 7 拍到 `wt_Ovld7`。
    

这样 **权重列** 与 **Input 特征窗口** 依旧 “先权重 1 拍” 的对位关系，  
逻辑、时序和你原来的 8 列架构完全兼容，只是把 **DDR → BRAM** 换掉了。

---

### 快速资源估算

|器件|需要|备注|
|---|---|---|
|BRAM18K|4 块|4 × 2.25 KB = 9 KB (> 8 KB)|
|LUT/FF|< 200|8 个地址译码、移位链|
|URAM|0|深度不足 2 K，不必用 URAM|

> 对 Z-7020 / Artix-7 级别 FPGA 只占几 %, 几乎“免费”。

---

> **总结一句话：**  
> 把 8 列 Buffer 每列做成 “8-bit × 1 K ROM”，总 8 KB 就能装下你这 4 层权重；  
> 时序、握手、移位链完全照旧，不动 PE，只在综合前 `$readmemh` 把权重烧进 BRAM 就搞定。
 
 
 
 
 **权重 Buffer 的完整工作过程** 拆成 4 个环节，指出每一环握手-时序要点，最后给一段 **可复用的参数化模版**（真正需要时直接拿去替换你那 8 份 `weight_bank?` Inst）。

---

## ① 写侧——从 DDR / Mem-Ctrl 把权重灌进 Buffer

| 端口                | 用法                        | 关键点                                 |
| ----------------- | ------------------------- | ----------------------------------- |
| `wt_I_vld`        | Mem-Ctrl 每拍送 **8 bit** 权重 | **只写 B 口** (`wea=0`,`web=wt_I_vld`) |
| `wt_I_addr[12:0]` | **连续地址** 0…(K·M·N/8-1)    | 保证对齐 1Byte；深度 8192 足够               |
| **写端口 Timing**    | 同步单端口 BRAM                | • 1 cycle write• `dina` 恒 0（只读取）    |

> **写端完全不用改**——只要 `wt_I_vld` 与 `wt_I_addr` 同拍稳定，IP 内部 1 拍就把权重写下去。

---

## ② 列读取握手——`wt_C?_O_vld`

```
Mem_Ctrl  ──┬─ wt_C0_O_vld ─(读列 0)─►  Weight_buf(A口)
            └─ wt_C1_O_vld ─(读列 1)─►
```

- 每当 **PE0** 需要下一列权重，Mem-Ctrl 把对应列地址 `wt_C?_addr`  
    和 **1 拍脉冲** `wt_C?_O_vld` 发下来。
    
- Buffer **打一拍**(`wt_C?_O_vld_1delay`) 再作为 **列 0 的使能**  
    (`wt_Ovld0`)，随后经 7 级移位形成 `wt_Ovld1-7`。  
    这样 PE8 列正好比 PE0 晚 7 拍收到权重，列链齐平。
    

---

## ③ 列地址与使能的 **“1 拍 OR”**

```verilog
assign wt_C0_O_vld_1more = wt_C0_O_vld | wt_C0_O_vld_1delay;
```

为什么要 `OR`？

> 如果 Mem-Ctrl 连续两拍拉高 `wt_C0_O_vld`（因为一个 kernel = 9 字节列）  
> 第一拍 IP 把权重字 **送到 A 口**，第二拍还未读完就会丢使能；  
> 取 “当前拍 | 上拍” 能把 **宽 2 拍** 的读窗口粘成 **一段稳定的使能**。

---

## ④ 读侧——双口 RAM（B 写 / A 读）

```verilog
// 例：列 0
weight_bank0 u0 (
    .clka (clk_cal),  .wea (1'b0),         .addra(wt_I_addr), .dina(8'b0),
    .clkb(clk_cal),  .enb (wt_C0_O_vld_1more), 
    .addrb(wt_C0_addr), .doutb(kernel_C0_O)
);
```

- **写端口 B**：`wt_I_addr` / `wt_I_vld`
    
- **读端口 A**：`wt_C?_addr` / `wt_C?_O_vld_1more`
    
- IP 自带 1-cycle 读延迟 → **`kernel_C?_O` 晚使能 1 拍**  
    （正好与 PE 中乘法器管线深度匹配）
    

---

## ★ 通用、节省资源的生成式模版

```verilog
// -------- 参数化权重 Buffer, 列数 = 8 ----------
generate
    genvar col;
    for(col=0; col<8; col=col+1) begin: GEN_WBUF
        wire       rd_en   = wt_C0_O_vld_1more << col;   // OR 后再移位
        wire [12:0]rd_addr = {wt_C0_addr, wt_C1_addr, wt_C2_addr,
                              wt_C3_addr, wt_C4_addr, wt_C5_addr,
                              wt_C6_addr, wt_C7_addr}[col*13 +: 13];

        weight_ram #(
            .AW (13), .DW (8)
        ) u_ram (
            .clk  (clk_cal),

            .we_b (wt_I_vld),
            .addr_b(wt_I_addr),
            .din_b (8'h00),          // 写端口

            .en_a (rd_en),
            .addr_a(rd_addr),
            .dout_a(kernel_C0_O + col) // 拼接到输出数组
        );
    end
endgenerate

// 输出 valid 移位链
always @(posedge clk_cal or negedge rst_cal_n)
    if(!rst_cal_n) {wt_Ovld7,wt_Ovld6,…,wt_Ovld0} <= 0;
    else           {wt_Ovld7,wt_Ovld6,…,wt_Ovld0} <= 
                   {wt_Ovld6,wt_Ovld5,…,wt_C0_O_vld_1delay};
```

- **一段代码** 生成 8 个 RAM，列数改写 `for` 上限即可。
    
- 把 `layer2weight_cnt` 若无特殊用途可以删去。
    
- 资源比 8 份固定 IP netlist 更友好，综合后仍落入 **双口 BRAM**。
    

---

## 结语

1. **写链**：`wt_I_vld` 同拍写 B 口 —— 1 clk 落 RAM
    
2. **读链**：`wt_C?_O_vld` → 打拍(OR) → 读 A 口 —— 1 clk 出 RAM
    
3. **列移位**：`wt_Ovld0` 初始，7 级移位到 `wt_Ovld7`
    
4. **PE**：权重字 & `wt_Ovld?` 同拍进入，各列对齐
    

只要你照着这四步确认时序，对齐不会出错；  
把上面的 **参数化生成模版** 粘进项目，可直接替换原先 8 份手动 IP 实例。





先把**“全片上权重”**这件事拆成三个硬约束、三个改动点、三个收益 / 代价——讲完你就能判断要不要这么干、该怎么干。

---

## 硬约束：算一笔“装得下吗”

|项目|公式|现网规模举例|
|---|---|---|
|**总权重量 (Byte)**|`K×K×M×N`|3×3×8×16 = 1 KB (卷积层1)3×3×32×64 ≈ 18 KB……|
|**FPGA BRAM/URAM 容量**|Xilinx 例：Z-7020≈140 KB BRAM|要把 **所有层** 累积；BRAM + URAM 总和是硬顶|
|**初始化映像体积**|`.bit` + `.mem`|几十 KB ~ 几 MB；超大时下载慢且占配置 Flash 空间|

> 一句话：**小模型** 可以一股脑塞片上；**中大模型** 必须选“最常用层”或“首次迭代”塞片上，其余仍走外存流。

---

## 改动点（代码 / 结构）

|#|现设计|全片上权重时怎么改|
|---|---|---|
|**1. 写口去掉**|`wt_I_vld`、`wt_I_addr` 写端口 B|改成 **ROM**：`we = 1'b0` 固定 0；或综合工具上选 _Read-only_|
|**2. BRAM 初始化**|运行时由 DMA 写|用 `readmemh/readmemb` 或 Vivado **Block Memory Generator** 的 `.mem init`；配置 Flash→bitstream 一起烧|
|**3. Mem_Ctrl**|负责搬权重 & 产生读列脉冲|只保留“列脉冲 + 地址”功能；搬运状态机可精简掉，节省逻辑|

示例：

```verilog
initial $readmemh("conv1_wt.mem", weight_bank0.U_ram.mem);
```

---

## 直接收益

1. **带宽清零**
    
    - DRAM 不再搬运权重，外存带宽全给 Feature Map。
        
2. **功耗下降**
    
    - DDR 省一大段突发读；FPGA 内部时钟门控后功耗低。
        
3. **时序更稳**
    
    - 去掉写口和行列仲裁，读端只剩纯 ROM → Fmax 通常↑。
        

---

## 代价 / 风险

|风险|细节|
|---|---|
|**片上容量爆**|卷积层 64×3×3×128 ≈ 294 KB，一层就塞满中档 FPGA。|
|**bitstream 体积↑，烧录慢**|每多 1 MB Flash，量产成本直接涨。|
|**权重不可热更新**|想换模型只能重编译 / 重新烧录；不适合动态部署。|
|**布线压力**|十几块 BRAM/URAM 贴阵列旁：局部布线密、可能拉低 Fmax。|

---

## 经验踩坑表

|场景|是否推荐|备注|
|---|---|---|
|MCU 固定算法，权重 ≤100 KB|✔ **直接 ROM**|上电即跑、功耗低|
|需要 OTA 更新模型|✘ 不推荐|仍走外存，或片上留双份权重区做热替换|
|纯 FPGA 方案且权重 ≤ BRAM 50%|✔ **小成本提速**|省 DDR，布线轻松|
|SoC + Linux，模型>1 MB|✘ 别塞全片上|用 PS-DMA + AXI HP 流|

---

## 结论一句话

> **“能一次塞完且以后不换模型” → 全片上；  
> 塞不下或模型常换 → 还是分层流。**

如果你决定塞片上——

1. 把 8 个 `weight_bank?` IP 改成 **ROM 模式** 或综合期的 `readmemb`；
    
2. `wt_I_*` 写口统统割掉，Mem_Ctrl 精简为 **读列脉冲生成器**；
    
3. 重新算片上 BRAM/URAM 用量，留 10–20% 余量给其它缓冲区，就可以收工。