## 1. 整体框架（Ping-Pong 双 Bank）

                 ┌───────── Mem_Ctrl 给 wr_addr / rd_addr ─────────┐
                 │                                                │
┌── 写数据选择 ──┤                                       ┌─ Bank-0 : map_10-17  ──┤─► PE 输入
│                            │                                       │                                        │
│                            │ Layer 偶 → 写 Bank-0   │ 读 Bank-1                        │
│ IOB_Data_vld ─►│ Layer 奇 → 写 Bank-1   │ 读 Bank-0                        │
└────────────────┘                                     └───────────────────────┘
## 2.关键握手关系

| 信号                    | 生产者      | 消费者                       | 作用     |
| --------------------- | -------- | ------------------------- | ------ |
| `wr_addr` / `rd_addr` | Mem_Ctrl | 本模块 16×RAM                | 地址统一   |
| `IOB_Data_vld`        | 输入阶段逻辑   | 写端 `wen_ram?`             | 写同步    |
| `Mem_Data_Ivld`       | Mem_Ctrl | 读端 enb + `IOB_Data_O_vld` | 读同步    |
| `IOB_Data_O_vld`      | 本模块      | Input_Regfile             | 数据到齐标志 |

- 写：IOB_Data_vld 必须与 8×Byte 同拍 → 地址、数据、wen 都在 同一拍。
- 读：Mem_Data_Ivld 必须与 rd_addr 同拍给 RAM，读出数据再经过 2 个 BRAM latency (2clk)，到 Input_Regfile 时用 IOB_Data_O_vld 对齐。
B口写，A口读

**`Mem_Data_Ivld`就是mem的`Data_O_vld`**	

| 网络阶段                 | 需要缓存到 BRAM 的 **最大**特征图        | 点数 (= W × H × C)        | 每 Bank 存 8 Byte需要多少行？ | 2048 行是否足够 |
| -------------------- | ----------------------------- | ----------------------- | --------------------- | ---------- |
| **卷积层 1** 输入 (原 ECG) | 64 × 64 × 3 = **12 288** Byte | 12 288 ÷ 8 = **1536** 行 | 1536 ≤ 2048           | ✔          |
| 卷积层 1 输出 / 卷积层 2 输入  | 32 × 32 × 8 = **8192** Byte   | 8192 ÷ 8 = **1024** 行   | 1024 ≤ 2048           | ✔          |
| 卷积层 2 输出 / Pool 输入   | 16 × 16 × 32 = **8192** Byte  | 8192 ÷ 8 = **1024** 行   | 1024 ≤ 2048           | ✔          |
| Pool 输出 / FC1 输入     | 3 × 3 × 32 = **288** Byte     | 288 ÷ 8 = **36** 行      | 36 ≪ 2048             | ✔          |
ram设置成2048深度
## 3.用ip还是自写rtl文件

大体功能可以做到“**一样用**”，但两种做法在 **实现细节、时序可靠性、资源利用率和后期维护** 上还是有区别——下面给你一张对照表，帮你快速判断什么时候用 IP、什么时候自己 RTL 描述再加 `(* ram_style="block" *)` 约束。

|维度|**IP（Block Memory Generator/UltraRAM 等）**|**自写 RTL + ram_style="block"**|
|---|---|---|
|**综合/布局布线**|Vivado 自动实例化原语、自动绑端口、时序模型精确；综合时会把 **地址/复位/使能** 等逻辑按 IP 配置固定下来。|依赖综合器推断；通常也能推成 Block-RAM，但必须：• 写端、读端各 1 个 `always` 块（或 read-first/write-first 指示）• 声明 `ram` 为 `reg`，再加 `ram_style="block"`约束写得不好可能被推成 LUTRAM。|
|**行为仿真**|IP 自带仿真模型，默认就等价于理想 BRAM。|你自己写的 RTL 就是仿真模型。逻辑越简单，仿真越快。|
|**功能灵活度**|图形界面可选：• 写/读优先级• 初始文件（.coe/.mem）• 输出寄存器、字节写使能、ECC…|需要手敲：• _Write first_ / _Read first_ / _No change_：靠读写地址与先后关系实现• 字节写使能要自己分段 • 初始内容：用 `$readmemh` / `$readmemb` 或在综合前覆写。|
|**时序收敛**|IP 会在端口自动插输出寄存器（勾选 “Enable output register”）——时序最好。|你要自己决定 output register。若忘记插拍或约束，可能出现时序负担。|
|**资源可见性**|报告里直接显示 **RAMB18/36/URAM** 数量。|只要推成 Block-RAM，报告也会显示一样的原语；但若推 LUTRAM 你得自己盯报告。|
|**易维护 / 团队协作**|Vivado 专案迁移有 `.xci`，把 IP 复制过去即可；对 FPGA 初学者友好。|纯 RTL 跨工具最方便（Quartus、Yosys 也能用）；不依赖 .xci。|
|**版图后仿、功耗**|厂家已验证的宏单元，功耗/布局更可控。|结论相同，只要被推成同类型宏单元。|
|**Debug 透明度**|IP 黑盒；但有带 `init_file` 方便预置数据。|RTL 可插自定义探针，逻辑完全可见；便于加断言和覆盖率。|

### 什么时候选哪一个？

|场景|推荐方案|
|---|---|
|**快速验证、功能优先、需要复杂选项（如 ECC、双时钟、宽度不对齐）**|IP|
|**追求跨平台、轻量级仓库、不希望带大量 .xci/.dcp**|RTL + `ram_style`|
|**同一项目里已经有大量 IP**，想保持一致|IP|
|教学/竞赛/开源，想让别人不用 Vivado GUI 就能综合|RTL|

---

### 强制映射注意点

1. ```verilog
    (* ram_style="block" *) reg [7:0] ram [0:DEPTH-1];
    ```
    
    - **不要再写 `synthesis translate_off/on`**；让综合器自动识别。
        
    - **DEPTH** 必须 ≥ 2；地址位宽要能覆盖深度。
        
2. **双端口写**
    
    - 如果 Port-A、Port-B 同时写同地址，FPGA 不同家族有不同冲突处理（Xilinx 读 X，Intel 不确定）。IP 会提供冲突处理选项，RTL 要自己避免或接受不确定。
        
3. **初始化文件**
    
    - IP：直接 `.coe` / `.mem` 勾选 “Load Init File”。
        
    - RTL：在 `initial` 块用 `$readmemh("file.mem", ram);`。
        
4. **时序**
    
    - IP 可自动加 **输出寄存器**，RTL 请在顶层对 `data_a` 再打一拍，或用 `read_first` 写法。
        

---

> **结论**  
> 只要 RTL 写法规范、加 `ram_style="block"`，综合后生成的网表与 IP 形式的 BRAM 在硬件资源层面没有差别；你可以按团队习惯决定用哪一种。