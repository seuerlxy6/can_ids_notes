## 1. 整体框架（Ping-Pong 双 Bank）

                 ┌───────── Mem_Ctrl 给 wr_addr / rd_addr ─────────┐
                 │                                                │
┌── 写数据选择 ──┤                                       ┌─ Bank-0 : map_10-17  ──┤─► PE 输入
│                            │                                       │                                        │
│                            │ Layer 偶 → 写 Bank-0   │ 读 Bank-1                        │
│ IOB_Data_vld ─►│ Layer 奇 → 写 Bank-1   │ 读 Bank-0                        │
└────────────────┘                                     └───────────────────────┘
## 2.关键握手关系

| 信号                    | 生产者      | 消费者                       | 作用     |
| --------------------- | -------- | ------------------------- | ------ |
| `wr_addr` / `rd_addr` | Mem_Ctrl | 本模块 16×RAM                | 地址统一   |
| `IOB_Data_vld`        | 输入阶段逻辑   | 写端 `wen_ram?`             | 写同步    |
| `Mem_Data_Ivld`       | Mem_Ctrl | 读端 enb + `IOB_Data_O_vld` | 读同步    |
| `IOB_Data_O_vld`      | 本模块      | Input_Regfile             | 数据到齐标志 |

- 写：IOB_Data_vld 必须与 8×Byte 同拍 → 地址、数据、wen 都在 同一拍。
- 读：Mem_Data_Ivld 必须与 rd_addr 同拍给 RAM，读出数据再经过 2 个 BRAM latency (2clk)，到 Input_Regfile 时用 IOB_Data_O_vld 对齐。
B口写，A口读

**`Mem_Data_Ivld`就是mem的`Data_O_vld`**	

| 网络阶段                 | 需要缓存到 BRAM 的 **最大**特征图        | 点数 (= W × H × C)        | 每 Bank 存 8 Byte需要多少行？ | 2048 行是否足够 |
| -------------------- | ----------------------------- | ----------------------- | --------------------- | ---------- |
| **卷积层 1** 输入 (原 ECG) | 64 × 64 × 3 = **12 288** Byte | 12 288 ÷ 8 = **1536** 行 | 1536 ≤ 2048           | ✔          |
| 卷积层 1 输出 / 卷积层 2 输入  | 32 × 32 × 8 = **8192** Byte   | 8192 ÷ 8 = **1024** 行   | 1024 ≤ 2048           | ✔          |
| 卷积层 2 输出 / Pool 输入   | 16 × 16 × 32 = **8192** Byte  | 8192 ÷ 8 = **1024** 行   | 1024 ≤ 2048           | ✔          |
| Pool 输出 / FC1 输入     | 3 × 3 × 32 = **288** Byte     | 288 ÷ 8 = **36** 行      | 36 ≪ 2048             | ✔          |
ram设置成2048深度
## 3.用ip还是自写rtl文件

大体功能可以做到“**一样用**”，但两种做法在 **实现细节、时序可靠性、资源利用率和后期维护** 上还是有区别——下面给你一张对照表，帮你快速判断什么时候用 IP、什么时候自己 RTL 描述再加 `(* ram_style="block" *)` 约束。

| 维度             | **IP（Block Memory Generator/UltraRAM 等）**                      | **自写 RTL + ram_style="block"**                                                                                                                |
| -------------- | -------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| **综合/布局布线**    | Vivado 自动实例化原语、自动绑端口、时序模型精确；综合时会把 **地址/复位/使能** 等逻辑按 IP 配置固定下来。 | 依赖综合器推断；通常也能推成 Block-RAM，但必须：• 写端、读端各 1 个 `always` 块（或 read-first/write-first 指示）• 声明 `ram` 为 `reg`，再加 `ram_style="block"`约束写得不好可能被推成 LUTRAM。 |
| **行为仿真**       | IP 自带仿真模型，默认就等价于理想 BRAM。                                       | 你自己写的 RTL 就是仿真模型。逻辑越简单，仿真越快。                                                                                                                  |
| **功能灵活度**      | 图形界面可选：• 写/读优先级• 初始文件（.coe/.mem）• 输出寄存器、字节写使能、ECC…             | 需要手敲：• _Write first_ / _Read first_ / _No change_：靠读写地址与先后关系实现• 字节写使能要自己分段 • 初始内容：用 `$readmemh` / `$readmemb` 或在综合前覆写。                        |
| **时序收敛**       | IP 会在端口自动插输出寄存器（勾选 “Enable output register”）——时序最好。            | 你要自己决定 output register。若忘记插拍或约束，可能出现时序负担。                                                                                                     |
| **资源可见性**      | 报告里直接显示 **RAMB18/36/URAM** 数量。                                 | 只要推成 Block-RAM，报告也会显示一样的原语；但若推 LUTRAM 你得自己盯报告。                                                                                                |
| **易维护 / 团队协作** | Vivado 专案迁移有 `.xci`，把 IP 复制过去即可；对 FPGA 初学者友好。                  | 纯 RTL 跨工具最方便（Quartus、Yosys 也能用）；不依赖 .xci。                                                                                                     |
| **版图后仿、功耗**    | 厂家已验证的宏单元，功耗/布局更可控。                                            | 结论相同，只要被推成同类型宏单元。                                                                                                                             |
| **Debug 透明度**  | IP 黑盒；但有带 `init_file` 方便预置数据。                                  | RTL 可插自定义探针，逻辑完全可见；便于加断言和覆盖率。                                                                                                                 |

### 什么时候选哪一个？

|场景|推荐方案|
|---|---|
|**快速验证、功能优先、需要复杂选项（如 ECC、双时钟、宽度不对齐）**|IP|
|**追求跨平台、轻量级仓库、不希望带大量 .xci/.dcp**|RTL + `ram_style`|
|**同一项目里已经有大量 IP**，想保持一致|IP|
|教学/竞赛/开源，想让别人不用 Vivado GUI 就能综合|RTL|

---

### 强制映射注意点

1. ```verilog
    (* ram_style="block" *) reg [7:0] ram [0:DEPTH-1];
    ```
    
    - **不要再写 `synthesis translate_off/on`**；让综合器自动识别。
        
    - **DEPTH** 必须 ≥ 2；地址位宽要能覆盖深度。
        
2. **双端口写**
    
    - 如果 Port-A、Port-B 同时写同地址，FPGA 不同家族有不同冲突处理（Xilinx 读 X，Intel 不确定）。IP 会提供冲突处理选项，RTL 要自己避免或接受不确定。
        
3. **初始化文件**
    
    - IP：直接 `.coe` / `.mem` 勾选 “Load Init File”。
        
    - RTL：在 `initial` 块用 `$readmemh("file.mem", ram);`。
        
4. **时序**
    
    - IP 可自动加 **输出寄存器**，RTL 请在顶层对 `data_a` 再打一拍，或用 `read_first` 写法。
        

---

> **结论**  
> 只要 RTL 写法规范、加 `ram_style="block"`，综合后生成的网表与 IP 形式的 BRAM 在硬件资源层面没有差别；你可以按团队习惯决定用哪一种。


## 4.`ram_wea = wrenb && !rdena;` 的含义

```verilog
wire ram_wea;
assign ram_wea = wrenb && (!rdena);
```

| 信号          | 来源                     | 含义                                       |
| ----------- | ---------------------- | ---------------------------------------- |
| **`wrenb`** | 写端口 B 的 `write enable` | “**想写**”——In-Out-Buffer 把新特征图送进 BRAM 时拉高 |
| **`rdena`** | 读端口 A 的 `read enable`  | “**正在读**”——Mem-Ctrl/PE 要从同一块 BRAM 读数据时拉高 |

> **目的：** **同一个时钟沿**里如果既想写又想读，就**先保证读**，把写关掉，避免**读写冲突**。

---

#### 1. 典型工作场景

| 时钟沿        | `rdena` | `wrenb` | `ram_wea` | 说明                                               |
| ---------- | ------- | ------- | --------- | ------------------------------------------------ |
| **Ping-写** | 0       | 1       | 1         | 当前层 `nn_layer_cnt[0]=1` → 写 **bank1**（CAN_bank1） |
| **Pong-读** | 1       | 0       | 0         | 另一半阵列在读 **bank0**，写端保持低                          |
| **冲突沿**    | 1       | 1       | 0         | 万一两边同时拉高，用 `!rdena` 禁掉这拍写                        |

> _Vivado 的 Block Memory Generator 在 **Simple Dual-Port (SDP)** 配置下，  
> 同时对 **同一个端口** 做读写会产生不确定数据或冲突警告。_  
> 因为 `addr_a/addr_b` 在系统里可能还没完全解耦（尤其 pipeline 阶段同拍发生时）。

---

#### 2. 如果 **确定两端口地址永不相同**

- 可以 **直接用 `ram_wea = wrenb`**，BRAM 支持 **两端口异步操作**。
    
- 但要确保：
    
    1. `addr_a` 与 `addr_b` **不在同一拍指向同一地址**；
        
    2. IP **配置为 True Dual-Port，独立写口**。
        

否则保持现在的 **互斥写** 更安全。

---

#### 3. 与 `SPI_start`、层流水的关系

- `SPI_start` 高时整块 BRAM 当作 **原始 ECG 环形缓冲**，  
    写端口实际来自 `IOB_Data_I_vld_ECG`，这里 `wrenb` 会被拉低或屏蔽。
    
- 层间 **Ping/Pong**：`nn_layer_cnt[0]` 决定是 **bank0** 还是 **bank1** 写入，  
    读端始终反相取另一半，配合 `ram_wea` 保证 **读优先**。
    

---

### 小贴士

1. **写、读在不同端口**且地址完全分离 → 直接用 `ram_wea = wrenb` 更高带宽。
    
2. 想保留“读优先”但允许并发，可做 **地址比较** 只屏蔽同地址冲突：
    
    ```verilog
    assign ram_wea = wrenb && !(rdena && (addr_a == addr_b));
    ```
    
3. 如果最后把 IP 配成 **独立时钟 True-DP**，Vivado 会内部处理冲突，可去掉该门控。