
# CAN-RGB + CANET-33K 入侵检测设计文档  
> 目标：给已有CAN总线 / 神经网络背景的研究生
> 范围：数据预处理 → RGB 编码 → 轻量 CNN 设计 → 一次性剪枝 + INT8 PTQ → 评估  
> 
---

## 0. 环境配置

| 类别      | 版本                                                                                         |
| ------- | ------------------------------------------------------------------------------------------ |
| Python  | 3.11                                                                                       |
| PyTorch | 2.5.1                                                                                      |

---

## 1、数据集与目录结构
[HCRL - Car-Hacking Dataset](https://ocslab.hksecurity.net/Datasets/car-hacking-dataset)
### HCRL Car-Hacking Dataset 
Car-Hacking-Dataset/
├── normal.csv                  # 正常行驶（约 30 min）
├── DoS_dataset.csv             # DoS 注入
├── Fuzzy_dataset.csv           # Fuzzy 随机注入
├── Gear_dataset.csv            # 变速挡位欺骗
└── RPM_dataset.csv             # 转速表欺骗
每个 .csv 文件都记录一段独立实验：约 30–40 min 总时长，期间重复 300 次注入事件，单次攻击持续 3–5 s

| 列名            | 类型    | 描述                   |
| ------------- | ----- | -------------------- |
| `Timestamp`   | float | 记录时间，Unix 秒          |
| `CAN ID`      | hex   | 11-bit ID（示例 `043f`） |
| `DLC`         | int   | Data Length Code，0–8 |
| `DATA[0]…[7]` | hex   | 0–8 字节报文内容           |
| `Flag`        | char  | `T`=注入帧，`R`=正常帧      |

### 代码目录
├─dataset_hack(原始数据集)
├─dataset_img_hack
**get_image.py生成的图片和标签,0.2代表取了原数据集每个csv20%的数据，具体比例可根据脚本中的参数修改，取不同数量的数据**
│  ├─0.2_can_images
│  ├─0.2_label.csv
├─get_image.py
├─dataloader_rgb.py（配合get_image）
├─CNN_RGB_NICE.py（保存原始模型，打印模型结构、保留原始训练验证函数）
├─purne.py（剪枝）
├─quant.py（量化）
├─rgb-main.py（主函数）
├─training_and_evaluation.py（训练测试脚本）
├─print.py（模型打印脚本）
├─can_net_cp_0.2_20.pth
├─can_net_cp_0.2_20.pthpruned_finetuned.pth
├─can_net_cp_0.2_20.pthpruned_quantized.pth
├─runs（tensorboard）
│  └─can_net_training
## 2、主函数--rgb-main.py
**整体流程**
原始 CAN 日志                                            
        │ 16 帧滑窗
16×16×3 CAN‑RGB 图像               
        │ 线性放大                            
        └────► 64×64×3 图像 ─► 轻量 CNN (CANET‑33K) ─► 一次式剪枝 + INT8 量(CANET‑7K) 

`if __name__ == "__main__":`  
    `model = CanNet_complex()`  
	//训练
    `train_model(model, img_dataloader, val_dataloader, log_dir='runs/can_net_cp_0.2_20', epochs=20, save_path='CNN/can_net_cp_0.2_20.pth')`  
    `model.load_state_dict(torch.load('CNN/can_net_cp_0.2_20.pth', weights_only=True))`  
    //验证
    `evaluate_model(model, test_dataloader)`  
    `device = torch.device("cuda" if torch.cuda.is_available() else "cpu")`  
	  //剪枝
    `model = run_structured_pruning(`  
        `model_class=CanNet_complex,`  
        `dataloaders=(img_dataloader, val_dataloader, test_dataloader),`  
        `original_model_path="CNN/can_net_cp_0.2_20.pth",`  
        `pruned_model_path="CNN/can_net_cp_0.2_20_pruned.pth",`  
        `device=device`  
    `)`  
	  //量化
    `quant_model = quantize_and_compare_model(`  
        `model_fp32=model,`  
        `calib_loader=cer_dataloader,`  
        `test_loader=test_dataloader,`  
        `fp32_path="CNN/can_net_cp_0.2_20_pruned.pth",`  
        `save_path="CNN/can_net_cp_0.2_20_pruned_quantized.pth"`  
    `)`
## 2、数据预处理CAN‑RGB 编码--dataloader_rgb.py
参考论文
S. Gao, L. Zhang, L. He, and F. Wang, “Attack detection for intelligent vehicles via CAN-bus: A lightweight image network approach,” IEEE Trans. Veh. Technol., vol. 72, no. 12, pp. 16 624–16 636, 2023.
将CAN报文序列数据转换成图像
CNN擅长识别颜色纹理异常，把时间、ID、数据长度这些维度映射进 RGB 通道，CNN就能发现入侵痕迹。

| 信息维度           | 映射规则                     |
| -------------- | ------------------------ |
| **时序**         | 第 _k_ 帧 → 第 _k_ 行        |
| **DLC（数据长度码）** | DLC 取值 0‑8 → 第 _x_ 列     |
| **ID**         | ID 低 12 位 → RGB 颜色（线性映射） |
| **空位**         | 填黑                       |

编码后得到 16×16×3 的小张量，再放大到 64×64 供 CNN 提取更细纹理

![[CAN_RGB_encoding_v4 (5).png]]

## 3. 基线网络 CANET-33K

```
Conv(3,8,k3) → BN+ReLU
Conv(8,32,k3,stride2) → BN+ReLU
MaxPool(2)
FC(32*3*3 → 16) → ReLU
FC(16 → 2)
```

- 总参数：32 960 ≈ 33 k
- FLOPs：2.31 M
- PyTorch 定义见 `models/canet.py`
    

---

## 4. 一次性混合压缩

### 4.1 结构化剪枝

- 目标稀疏率：50 % 通道级
- 方法：`torch.nn.utils.prune.ln_structured`
- 剪枝后参数 ↓ 到 7218

### 4.2 INT8 Post-Training Quantisation

```python
backend = 'fbgemm'
model.eval()
qconfig = torch.ao.quantization.get_default_qconfig(backend)
qmodel  = torch.ao.quantization.quantize_dynamic(
            model, {nn.Linear}, dtype=torch.qint8)
```

- 参数尺寸：**7 208**
- 存储：**17.05 kB**
- 精度保持：99.72 %

---

## 5. 训练-剪枝-量化流水线

```bash
python scripts/00_rgb_encode.py   # 原始 CAN → .npy
python scripts/10_train_fp32.py   # 20 epochs baseline
python scripts/20_prune.py        # 50 % structured
python scripts/30_ptq_int8.py     # dynamic quant
python scripts/40_eval.py         # 报告 ACC / F1 / ROC
```

输出示例：

```
FP32  : acc 99.89 | params 32.9k
Prune : acc 99.78 | params 7.2k
INT8  : acc 99.72 | params 7.2k  (17.05 kB)
```

    

---