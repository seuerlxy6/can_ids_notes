
# CAN-RGB + CANET-33K 入侵检测设计文档  
> 目标：给已有CAN总线 / 神经网络背景的研究生
> 范围：数据预处理 → RGB 编码 → 轻量 CNN 设计 → 一次性剪枝 + INT8 PTQ → 评估  
> 
---

## 0. 环境配置

| 类别      | 版本                                                                                         |
| ------- | ------------------------------------------------------------------------------------------ |
| Python  | 3.11                                                                                       |
| PyTorch | 2.5.1                                                                                      |

---

## 1、数据集与目录结构
[HCRL - Car-Hacking Dataset](https://ocslab.hksecurity.net/Datasets/car-hacking-dataset)
### HCRL Car-Hacking Dataset 
Car-Hacking-Dataset/
├── normal.csv                  # 正常行驶（约 30 min）
├── DoS_dataset.csv             # DoS 注入
├── Fuzzy_dataset.csv           # Fuzzy 随机注入
├── Gear_dataset.csv            # 变速挡位欺骗
└── RPM_dataset.csv             # 转速表欺骗
每个 .csv 文件都记录一段独立实验：约 30–40 min 总时长，期间重复 300 次注入事件，单次攻击持续 3–5 s

| 列名            | 类型    | 描述                   |
| ------------- | ----- | -------------------- |
| `Timestamp`   | float | 记录时间，Unix 秒          |
| `CAN ID`      | hex   | 11-bit ID（示例 `043f`） |
| `DLC`         | int   | Data Length Code，0–8 |
| `DATA[0]…[7]` | hex   | 0–8 字节报文内容           |
| `Flag`        | char  | `T`=注入帧，`R`=正常帧      |

### 代码目录
├─dataset_hack(原始数据集)
├─dataset_img_hack
**get_image.py生成的图片和标签,0.2代表取了原数据集每个csv20%的数据，具体比例可根据脚本中的参数修改，取不同数量的数据**
│  ├─0.2_can_images
│  ├─0.2_label.csv
├─get_image.py
├─dataloader_rgb.py（配合get_image）
├─CNN_RGB_NICE.py（保存原始模型，打印模型结构、保留原始训练验证函数）
├─purne.py（剪枝）
├─quant.py（量化）
├─rgb-main.py（主函数）
├─training_and_evaluation.py（训练测试脚本）
├─print.py（模型打印脚本）
├─can_net_cp_0.2_20.pth
├─can_net_cp_0.2_20.pthpruned_finetuned.pth
├─can_net_cp_0.2_20.pthpruned_quantized.pth
├─runs（tensorboard）
│  └─can_net_training
## 2、主函数
`if __name__ == "__main__":`  
    `model = CanNet_complex()`  
    `train_model(model, img_dataloader, val_dataloader, log_dir='runs/can_net_cp_0.2_20', epochs=20, save_path='CNN/can_net_cp_0.2_20.pth')`  
    `model.load_state_dict(torch.load('CNN/can_net_cp_0.2_20.pth', weights_only=True))`  
    `evaluate_model(model, test_dataloader)`  
    `device = torch.device("cuda" if torch.cuda.is_available() else "cpu")`  
  
    `model = run_structured_pruning(`  
        `model_class=CanNet_complex,`  
        `dataloaders=(img_dataloader, val_dataloader, test_dataloader),`  
        `original_model_path="CNN/can_net_cp_0.2_20.pth",`  
        `pruned_model_path="CNN/can_net_cp_0.2_20_pruned.pth",`  
        `device=device`  
    `)`  
  
    `quant_model = quantize_and_compare_model(`  
        `model_fp32=model,`  
        `calib_loader=cer_dataloader,`  
        `test_loader=test_dataloader,`  
        `fp32_path="CNN/can_net_cp_0.2_20_pruned.pth",`  
        `save_path="CNN/can_net_cp_0.2_20_pruned_quantized.pth"`  
    `)`
## 2、数据预处理
````
> **数据标准**  
> | 字段 | 位宽 | 说明 |  
> |------|------|------|  
> | `timestamp` | 64 bit | us 级采样时间戳 |  
> | `id`        | 11/29 bit | CAN 标识符 |  
> | `dlc`       | 4 bit | 数据长度码 |  
> | `data`      | ≤ 64 bit | 以字节序列存储 |

---

## 2. CAN-RGB 编码  
核心思路：把 *时间*、*ID*、*DLC* 三个维度塞进一张 64 × 64 × 3 的图。

| 通道 | 填充值 | 归一化策略 |
|------|--------|-----------|
| **R** | `timestamp Δt` (μs) | log-minmax (剪长尾) |
| **G** | 标识符 ID | /2048 (11-bit) |
| **B** | DLC | /8 |

````

---

## 3. 基线网络 CANET-33K

```
Conv(3,8,k3) → BN+ReLU
Conv(8,32,k3,stride2) → BN+ReLU
MaxPool(2)
FC(32*3*3 → 16) → ReLU
FC(16 → 2)
```

- 总参数：32 960 ≈ 33 k
- FLOPs：2.31 M
- PyTorch 定义见 `models/canet.py`
    

---

## 4. 一次性混合压缩

### 4.1 结构化剪枝

- 目标稀疏率：50 % 通道级
- 方法：`torch.nn.utils.prune.ln_structured`
- 剪枝后参数 ↓ 到 7218

### 4.2 INT8 Post-Training Quantisation

```python
backend = 'fbgemm'
model.eval()
qconfig = torch.ao.quantization.get_default_qconfig(backend)
qmodel  = torch.ao.quantization.quantize_dynamic(
            model, {nn.Linear}, dtype=torch.qint8)
```

- 参数尺寸：**7 208**
- 存储：**17.05 kB**
- 精度保持：99.72 %

---

## 5. 训练-剪枝-量化流水线

```bash
python scripts/00_rgb_encode.py   # 原始 CAN → .npy
python scripts/10_train_fp32.py   # 20 epochs baseline
python scripts/20_prune.py        # 50 % structured
python scripts/30_ptq_int8.py     # dynamic quant
python scripts/40_eval.py         # 报告 ACC / F1 / ROC
```

输出示例：

```
FP32  : acc 99.89 | params 32.9k
Prune : acc 99.78 | params 7.2k
INT8  : acc 99.72 | params 7.2k  (17.05 kB)
```

    

---