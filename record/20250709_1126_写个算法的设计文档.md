
# CAN-RGB + CANET-33K 入侵检测设计文档  
> 目标：给已有CAN总线 / 神经网络背景的研究生
> 范围：数据预处理 → RGB 编码 → 轻量 CNN 设计 → 一次性剪枝 + INT8 PTQ → 评估  
> 
---

## 0. 环境配置

| 类别      | 版本                                                                                         |
| ------- | ------------------------------------------------------------------------------------------ |
| Python  | 3.11                                                                                       |
| PyTorch | 2.5.1                                                                                      |

---

## 1、数据集与目录结构
[HCRL - Car-Hacking Dataset](https://ocslab.hksecurity.net/Datasets/car-hacking-dataset)
### HCRL Car-Hacking Dataset 
Car-Hacking-Dataset/
├── normal.csv                  # 正常行驶（约 30 min）
├── DoS_dataset.csv             # DoS 注入
├── Fuzzy_dataset.csv           # Fuzzy 随机注入
├── Gear_dataset.csv            # 变速挡位欺骗
└── RPM_dataset.csv             # 转速表欺骗
每个 .csv 文件都记录一段独立实验：约 30–40 min 总时长，期间重复 300 次注入事件，单次攻击持续 3–5 s

| 列名            | 类型    | 描述                   |
| ------------- | ----- | -------------------- |
| `Timestamp`   | float | 记录时间，Unix 秒          |
| `CAN ID`      | hex   | 11-bit ID（示例 `043f`） |
| `DLC`         | int   | Data Length Code，0–8 |
| `DATA[0]…[7]` | hex   | 0–8 字节报文内容           |
| `Flag`        | char  | `T`=注入帧，`R`=正常帧      |

### 代码目录
├─dataset_hack(原始数据集)
├─dataset_img_hack
**get_image.py生成的图片和标签,0.2代表取了原数据集每个csv20%的数据，具体比例可根据脚本中的参数修改，取不同数量的数据**
│  ├─0.2_can_images
│  ├─0.2_label.csv
├─get_image.py
├─dataloader_rgb.py（配合get_image）
├─CNN_RGB_NICE.py（保存原始模型，打印模型结构、保留原始训练验证函数）
├─purne.py（剪枝）
├─quant.py（量化）
├─rgb-main.py（主函数）
├─training_and_evaluation.py（训练测试脚本）
├─print.py（模型打印脚本）
├─can_net_cp_0.2_20.pth
├─can_net_cp_0.2_20.pthpruned_finetuned.pth
├─can_net_cp_0.2_20.pthpruned_quantized.pth
├─runs（tensorboard）
│  └─can_net_training
## 2、主函数--rgb-main.py
**整体流程**
原始 CAN 日志                                            
        │ 16 帧滑窗
16×16×3 CAN‑RGB 图像               
        │ 线性放大                            
        └────► 64×64×3 图像 ─► 轻量 CNN (CANET‑33K) ─► 一次式剪枝 + INT8 量(CANET‑7K) 

`if __name__ == "__main__":`  
    `model = CanNet_complex()`  
	//训练
    `train_model(model, img_dataloader, val_dataloader, log_dir='runs/can_net_cp_0.2_20', epochs=20, save_path='CNN/can_net_cp_0.2_20.pth')`  
    `model.load_state_dict(torch.load('CNN/can_net_cp_0.2_20.pth', weights_only=True))`  
    //验证
    `evaluate_model(model, test_dataloader)`  
    `device = torch.device("cuda" if torch.cuda.is_available() else "cpu")`  
	  //剪枝
    `model = run_structured_pruning(`  
        `model_class=CanNet_complex,`  
        `dataloaders=(img_dataloader, val_dataloader, test_dataloader),`  
        `original_model_path="CNN/can_net_cp_0.2_20.pth",`  
        `pruned_model_path="CNN/can_net_cp_0.2_20_pruned.pth",`  
        `device=device`  
    `)`  
	  //量化
    `quant_model = quantize_and_compare_model(`  
        `model_fp32=model,`  
        `calib_loader=cer_dataloader,`  
        `test_loader=test_dataloader,`  
        `fp32_path="CNN/can_net_cp_0.2_20_pruned.pth",`  
        `save_path="CNN/can_net_cp_0.2_20_pruned_quantized.pth"`  
    `)`
## 3、数据预处理CAN‑RGB 编码--dataloader_rgb.py
参考论文
S. Gao, L. Zhang, L. He, and F. Wang, “Attack detection for intelligent vehicles via CAN-bus: A lightweight image network approach,” IEEE Trans. Veh. Technol., vol. 72, no. 12, pp. 16 624–16 636, 2023.
将CAN报文序列数据转换成图像
CNN擅长识别颜色纹理异常，把时间、ID、数据长度这些维度映射进 RGB 通道，CNN就能发现入侵痕迹。

| 信息维度           | 映射规则                     |
| -------------- | ------------------------ |
| **时序**         | 第 _k_ 帧 → 第 _k_ 行        |
| **DLC（数据长度码）** | DLC 取值 0‑8 → 第 _x_ 列     |
| **ID**         | ID 低 12 位 → RGB 颜色（线性映射） |
| **空位**         | 填黑                       |

编码后得到 16×16×3 的小张量，再放大到 64×64 供 CNN 提取更细纹理

![[CAN_RGB_encoding_v4 (5).png]]

## 4、轻量 CNN（CANET‑33K）——CNN_RGB_NICE.py
多种尝试后确定的网络结构（参照lenet5）
- 3 个卷积（带 stride 直接下采样）+ 1 个 MaxPool + 两层全连接
- 参数量：32 962（132 kB）
- 这里可以自己去跑print.py 更直观

|层级|配置|输出尺寸|参数量|
|---|---|---|---|
|Conv1|3→16, 3×3, s2|16×32×32|448|
|Conv2|16→32, 3×3, s2|32×16×16|4 640|
|Conv3|32→32, 3×3, s2|32×8×8|9 248|
|MaxPool|4×4, s2|32×3×3|0|
|FC1|288→64|64|18 432|
|FC2|64→2|2|130|
## 5、剪枝 + INT8 量化——purne.py quant.py

| 步骤           | 关键操作                                        | 结果                                               |
| ------------ | ------------------------------------------- | ------------------------------------------------ |
| **结构化剪枝**    | L1‑norm 选最弱通道删掉一半；FC 单元砍 3/4；再微调 10 个 epoch | 参数 ↓78 % → 7 208；MACs ↓62 % → 0.88 M；精度仍 99.72 % |
| **INT8 PTQ** | 用 1 万张未见过的样本做校准，fbgemm 后端                   | 文件尺寸 ↓到 17 kB；精度无损相较结构化剪枝                        |




## 6 训练与评估设置

- **数据集**：公开多攻击类型 CAN 日志，共 124 k 张编码图。
    
- **划分**：8:1:1（Train:Val:Test），额外 10 k 张做量化校准。
    
- **优化器**：Adam，批量 32；学习率余弦退火。
    
- **指标**：Accuracy/F1/FNR + 参数量、模型大小、MACs。
    

> 通过 Early‑Stopping，可在 15‑20 分钟内用 CPU 完成本地微调。

---

## 7 主要实验对比

|模型|尺寸|MACs|准确率|
|---|---|---|---|
|Inception‑ResNet|7 MB|18 M|99.9 %|
|Gao 2023 轻量 CNN|280 kB|—|99.7 %|
|**本工作 INT8**|**17 kB**|0.88 M|**99.72 %**|

> 结果说明：在尺寸上 **比深模型小 410 倍**，性能几乎相当；非常适合资源受限的车载 ECU。

---

## 8 假设与局限

- 只覆盖 DoS、Fuzzy、Gear、RPM 四类攻击。
    
- 滑窗固定 16 帧，未尝试自适应大小。
    
- 使用 8bit 对称量化，更低位宽留待后续研究。
    

---

## 9 后续改进方向

1. **量化感知训练（QAT）**：进一步恢复极端剪枝场景的精度。
    
2. **稀疏训练**：尝试 Lottery Ticket / SLT 方案，冲击 <10 k 参数。
    
3. **硬件闭环验证**：把 INT8 模型烧录到 MCU/FPGA，实测端到端延迟；对比 ECU 实时窗口需求。
    

## 4. 一次性混合压缩

### 4.1 结构化剪枝

- 目标稀疏率：50 % 通道级
- 方法：`torch.nn.utils.prune.ln_structured`
- 剪枝后参数 ↓ 到 7218

### 4.2 INT8 Post-Training Quantisation

```python
backend = 'fbgemm'
model.eval()
qconfig = torch.ao.quantization.get_default_qconfig(backend)
qmodel  = torch.ao.quantization.quantize_dynamic(
            model, {nn.Linear}, dtype=torch.qint8)
```

- 参数尺寸：**7 208**
- 存储：**17.05 kB**
- 精度保持：99.72 %

---

## 5. 训练-剪枝-量化流水线

```bash
python scripts/00_rgb_encode.py   # 原始 CAN → .npy
python scripts/10_train_fp32.py   # 20 epochs baseline
python scripts/20_prune.py        # 50 % structured
python scripts/30_ptq_int8.py     # dynamic quant
python scripts/40_eval.py         # 报告 ACC / F1 / ROC
```

输出示例：

```
FP32  : acc 99.89 | params 32.9k
Prune : acc 99.78 | params 7.2k
INT8  : acc 99.72 | params 7.2k  (17.05 kB)
```

    

---