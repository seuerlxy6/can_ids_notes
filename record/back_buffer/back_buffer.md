我希望这个文件能复用，conv层的输出也能通过这个buffer，整理好8个一组写回，conv层输出是8个通道每个通道数据32×32，如果要整理就是，等8次，每个通道都同时填满8个数据就可以写回8次，按通道顺序写，omap1的8个数是一个地址，omap2的8个数是一个地址，以此类推，这部分的地址由memctrl给出，还有fc层

以 8 通道为例：

- PE 输出顺序：  
    每拍：`{ch0(p0), ch1(p0), ..., ch7(p0)}`  
    再下一拍：`{ch0(p1), ch1(p1), ..., ch7(p1)}`  
    ……按空间点在跑。
    
- IOB 想要的是：
    
    - addr0：`ch0 的 [p0..p7]`（8 个连续点）
        
    - addr1：`ch1 的 [p0..p7]`
        
    - ……
        
    - addr7：`ch7 的 [p0..p7]`  
        然后再是 `ch0 的 [p8..p15]` 之类的。

 **Conv 层写回前**：需要一个 **8×8 的小转置 buffer**（64 B），做通道内打包；
    
-**Pool 层写回前**：需要一个 **32ch × 9 的 buffer**（288 B），做 3×3×32 → 288 的一维展开

由于输入是 8 通道并行（1拍1个点），输出想要 8 个空间点并行（1拍1个通道），这意味着我们需要积累 8 拍的数据，形成一个 **8(Channel) × 8(Time)** 的数据块，然后进行“转置”读取。

- **输入侧 (Write)**：每拍写入一列 `{ch0..ch7}`，写 8 拍。
    
- **输出侧 (Read)**：每拍读出一行 `{p0..p7}`，读 8 拍。
    
- **统一性**：对于 Pool 层的 $32ch \times 9$ 需求，本质上是数据流的切分。只要基础单元能完成 $8 \times 8$ 的颗粒度转换，外层的状态机（FSM）控制读取顺序即可。