## 流水线？
写端把 3 行数据轮流写入同 160 Byte 的环形缓冲区，而读端对这 3 行的消费始终 比写端早两个 pe_end 周期？
**每拍写 8 B，PE 每拍吃 16×8 bit，计算流水永远比写端快两个 pe_end 节拍**
### 时间线（举例：Hu_w = 33，K_H = 3，Stride =2）

| pe_end 周期 | 正在写入的行 | 正在被读的行        | 读写关系                   |
| --------- | ------ | ------------- | ---------------------- |
| **T0** 开始 | row 0  | —             | 只写不读                   |
| T1        | row 0  | row 0         | 同一行，读滞后 1 pe_end       |
| T2        | row 1  | row 0 & row 1 | row 0 最后几列读完后就可被覆盖     |
| T3        | row 2  | row 0/1/2     | 三行齐全，完成第一个 3×3 卷积窗口    |
| T4        | row 3  | row 1/2/3     | row 0 已不再需要，被 row 3 覆盖 |

---

## 1 行宽 33、总深 99 时的写-读时序

|量|数值|含义|
|---|---|---|
|**Hu₍w₎**|33 Byte|一行像素数|
|**ROW_BLK**|ceil(33 / 8) = 5|一行被切成 5 个 8 B 列块|
|**行缓冲孔径**|5 × 8 = 40 Byte|一行真实占用字节|
|**环形缓冲大小**|40 × 3 = 120 Byte|3 行正好放下（原 160 B 仍够）|


---
### 为什么要把 **`IR_Data_I_vld`** 再打一拍 (`IR_Data_I_vld_1delay`) 后才作为写使能？

> **核心理由：  
> 让“地址”与“数据”处在**同一拍**，  
> 再一起喂给寄存器文件写口。**

---

| 信号                                                                          | 第 N 拍 | 第 N + 1 拍   |
| --------------------------------------------------------------------------- | ----- | ----------- |
| **外部握手**  <br>`IR_Data_I_vld`  <br>`Bm_cnt_in`                              | **1** | 0           |
| **对齐后的内部信号**  <br>`Bm_cnt_in_1delay` → `Bm_cnt`  <br>`IR_Data_I_vld_1delay` | 0     | **1**       |
| **写地址**  <br>`wr_addr = Bm_cnt × 8`                                         | 计算得到  | **稳定**      |
| **写数据**  <br>`IR_Data_I[7:0]`                                               | 已经送到  | **保持不变**    |
| **写使能**                                                                     | 0     | **1** → 执行写 |

1. **地址来自 `Bm_cnt`，而 `Bm_cnt` 本身就是把外部的 `Bm_cnt_in` 打了一拍再用**。
