## 流水线？
写端把 3 行数据轮流写入同 160 Byte 的环形缓冲区，而读端对这 3 行的消费始终 比写端早两个 pe_end 周期？
**每拍写 8 B，PE 每拍吃 16×8 bit，计算流水永远比写端快两个 pe_end 节拍**
### 时间线（举例：Hu_w = 33，K_H = 3，Stride =2）

| pe_end 周期 | 正在写入的行 | 正在被读的行        | 读写关系                   |
| --------- | ------ | ------------- | ---------------------- |
| **T0** 开始 | row 0  | —             | 只写不读                   |
| T1        | row 0  | row 0         | 同一行，读滞后 1 pe_end       |
| T2        | row 1  | row 0 & row 1 | row 0 最后几列读完后就可被覆盖     |
| T3        | row 2  | row 0/1/2     | 三行齐全，完成第一个 3×3 卷积窗口    |
| T4        | row 3  | row 1/2/3     | row 0 已不再需要，被 row 3 覆盖 |

---

## 1 行宽 33、总深 99 时的写-读时序

|量|数值|含义|
|---|---|---|
|**Hu₍w₎**|33 Byte|一行像素数|
|**ROW_BLK**|ceil(33 / 8) = 5|一行被切成 5 个 8 B 列块|
|**行缓冲孔径**|5 × 8 = 40 Byte|一行真实占用字节|
|**环形缓冲大小**|40 × 3 = 120 Byte|3 行正好放下（原 160 B 仍够）|


---


### 为什么要把 **`IR_Data_I_vld`** 再打一拍 (`IR_Data_I_vld_1delay`) 后才作为写使能？

> **核心理由：  
> 让“地址”与“数据”处在**同一拍**，  
> 再一起喂给寄存器文件写口。**

---

|信号|第 N 拍|第 N + 1 拍|
|---|---|---|
|**外部握手**`IR_Data_I_vld``Bm_cnt_in`|**1**|0|
|**对齐后的内部信号**`Bm_cnt_in_1delay` → `Bm_cnt``IR_Data_I_vld_1delay`|0|**1**|
|**写地址**`wr_addr = Bm_cnt × 8`|计算得到|**稳定**|
|**写数据**`IR_Data_I[7:0]`|已经送到|**保持不变**|
|**写使能**|0|**1** → 执行写|

1. **地址来自 `Bm_cnt`，而 `Bm_cnt` 本身就是把外部的 `Bm_cnt_in` 打了一拍再用**。
    
    - 在第 N 拍，`Bm_cnt` 还等于 **上一行** 的列号。
        
    - 只有到 **第 N + 1 拍**，`Bm_cnt` 才是真正要写的列号。
        
2. 如果直接用 **未延迟** 的 `IR_Data_I_vld` 作写使能，
    
    - 第 N 拍就会把 **新数据** 写到 **旧地址**，数据→地址 **错位一列**。
        
3. 把写使能延后一拍后：
    
    - **地址、数据、使能** 都在 **第 N + 1 拍** 同时有效，
        
    - 写入的 8 Byte 与它们所属的列（`Bm_cnt`）严格对应。
        

---

### 和读口的配合

- 读侧也把 `Weight_Data_Ovld` 打一拍再当读使能。
    
- 这样 **读、写各自多 1 拍**，整条流水深度一致，  
    写完一列 **正好** 能被下一拍（或下几拍）的读逻辑取到，  
    不会出现“读早/晚一个地址”的竞争。
    

---

#### 小结

> **打一拍 ≈ 给地址计算留一个节拍**  
> 让 **“地址”** 与 **“数据”** 在同一个时钟沿被送进寄存器文件，  
> 从而保证 Buffer 内部存储完全对齐，  
> 后续读取窗口时不会拿到错行、错列的数据。