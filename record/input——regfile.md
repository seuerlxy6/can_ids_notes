## 流水线？
写端把 3 行数据轮流写入同 160 Byte 的环形缓冲区，而读端对这 3 行的消费始终 比写端早两个 pe_end 周期？
**每拍写 8 B，PE 每拍吃 16×8 bit，计算流水永远比写端快两个 pe_end 节拍**
### 时间线（举例：Hu_w = 33，K_H = 3，Stride =2）

| pe_end 周期 | 正在写入的行 | 正在被读的行        | 读写关系                   |
| --------- | ------ | ------------- | ---------------------- |
| **T0** 开始 | row 0  | —             | 只写不读                   |
| T1        | row 0  | row 0         | 同一行，读滞后 1 pe_end       |
| T2        | row 1  | row 0 & row 1 | row 0 最后几列读完后就可被覆盖     |
| T3        | row 2  | row 0/1/2     | 三行齐全，完成第一个 3×3 卷积窗口    |
| T4        | row 3  | row 1/2/3     | row 0 已不再需要，被 row 3 覆盖 |

---

## 1 行宽 33、总深 99 时的写-读时序

|量|数值|含义|
|---|---|---|
|**Hu₍w₎**|33 Byte|一行像素数|
|**ROW_BLK**|ceil(33 / 8) = 5|一行被切成 5 个 8 B 列块|
|**行缓冲孔径**|5 × 8 = 40 Byte|一行真实占用字节|
|**环形缓冲大小**|40 × 3 = 120 Byte|3 行正好放下（原 160 B 仍够）|

### 写-读相对节拍

T0-T1：写 row0，读端尚未启动或只读 row0 前几列。

T2：写 row1；读端正读 row0 的后半行 + row1 前半行。

T3：写 row2；读端已经能拿到 row0/1/2 三行 → 第一批 3 × 3 卷积窗口。

T4：写 row3 覆盖 row0；此时 row0 全部列块已被消耗完，覆盖合法。

写端比读端“落后 2 行”，核高 = 3 → 落后行数 ≥ K-1，一定 不会抢写尚未读的数据。
因而 Weight_Data_Ovld ↔ IR_Data_O_vld 的 ready/valid 时序 完全不受行宽变窄影响；
你的握手逻辑照旧有效，不会产生 under-run / over-run。
---

### 写端地址公式

```verilog
wr_addr = Bm_cnt * 8;     // Bm_cnt : 0 … ROW_BLK-1
