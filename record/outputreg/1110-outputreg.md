relu每次输出8通道的16个数据，然后在输出通道上循环
maxpool16_16_32——>3_3_32
需要32个reg存储，无法复用（计算顺序决定）
1输出：每个reg至少存16_8个数据——>产生3个8_8的窗口
2移位：滑动步长为4，,1个8byte的line buffer右移4位清除旧数据
3填充：新的16个数据进入
按照他的逻辑改成二维缓冲也就是16个8byte的行缓冲，填充满16*8产生3个8*8的窗口，依次进入pool64单元计算，然后清空，整体移位4个字节，也就是清空每个行缓冲的前4个数据，等待下一批16个数据进入，填充4次后又可以产生3个8*8的窗口，循环3次，最终生成9个窗口


写32个reg代表这32个通道，帮我写每个通道内部存储滑动生成窗口的verilog，16*16的图，8*8的窗口，滑动步长为4，数据按行输入，先输入第一行16个再输入下一行这样，也就是说要输入8行才能生成一个窗口


**位拼接，二维的窗口数据写进一维总线 `win_bus`**

win_bus[((r×K + c)+1)×DATAW-1 -: DATAW] <= linebuf[r]【col-(K-1)+c】
举个例子：

- 当 r=0,c=0：`((0*8+0)+1)*8-1 = 7` → `win_bus[7:0]` 存放窗口左上角像素。
    
- 当 r=0,c=1：`((0*8+1)+1)*8-1 = 15` → `win_bus[15:8]` 存第 2 个像素。
    
- …以此类推直到 `r=7,c=7`，总共 64 个字节覆盖整个窗口。
- 
右边的 `linebuf[r][col-(K-1)+c]` 则是从**行缓冲**取出第 `r` 行、第 `col-7+c` 列的像素（当前列往左数 7 再往右偏移 c）。这样保证抓到最近的 8 列。