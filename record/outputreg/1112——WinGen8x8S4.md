每拍输入一个像素，按行主序存入
行列计数
 reg [DATAW-1:0] linebuf [0:K-1][0:IMG_W-1];
只保存最近的8行，换行时整体下移
行尾（`col==15`）时**只置位**`roll_pending`；到**下一拍的列0**时（新行第1个像素），先做“上移”，再正常写入这一拍的数据，防止上移和最后一列数据写同时发生，导致最后一列数据无法上移
在 (row,col) ∈ {(7/11/15),(7/11/15)} 时拉高 win_valid 1 拍，并在 win_bus 输出 64 个像素
(row,col)=(15,15) 时给出一拍frame_done



**问题本质**：  
在行缓冲（`linebuf`）中，写入当前行最后一列 (`col=15`) 后立刻执行“整行上移”。  
但因为都是非阻塞赋值 (`<=`)，**上移时读到的仍是上一拍的旧值**，导致最后一列数据没被推上去。

---

**现象**：  
波形显示最后一行的末列（如值 `15`）没有进入上一行，窗口生成时缺一列。

---

**原因**：  
非阻塞赋值在同一拍内“先计算右值、最后统一更新”。  
所以上移语句里的 `linebuf[6][i] <= linebuf[7][i];`  
读到的 `linebuf[7][i]` 是**还没被写入最后一列的新值之前的状态**。

---

**两种解决思路**：

1. **推迟上移（推荐）**  
    在行尾只打一个标志，等到**下一行第一列输入时**再执行“上移”。  
    这样 `linebuf[7]` 的数据已经完整更新，读到的就是正确的。  
    ✔ 安全、仿真与综合一致。
    
2. **改用阻塞赋值（权宜之计）**  
    在时序块中用 `=`，让仿真顺序变成“先写后读”，  
    仿真中看起来正确，但硬件并不保证这一执行顺序。  
    ⚠ 风险：仿真与综合行为不一致，后续易出错。
    

---

**总结一句话**：  
你的问题是**非阻塞赋值导致的读旧值**，正确解法是**让上移延后一拍执行**，  
而不是靠阻塞赋值强行改顺序。