每拍输入一个像素，按行主序存入
行列计数
 reg [DATAW-1:0] linebuf [0:K-1][0:IMG_W-1];
只保存最近的8行，换行时整体下移
行尾（`col==15`）时**只置位**`roll_pending`；到**下一拍的列0**时（新行第1个像素），先做“上移”，再正常写入这一拍的数据，防止上移和最后一列数据写同时发生，导致最后一列数据无法上移
在 (row,col) ∈ {(7/11/15),(7/11/15)} 时拉高 win_valid 1 拍，并在 win_bus 输出 64 个像素
(row,col)=(15,15) 时给出一拍frame_done



**问题本质**：  
在行缓冲（`linebuf`）中，写入当前行最后一列 (`col=15`) 后立刻执行“整行上移”。  
但因为都是非阻塞赋值 (`<=`)，**上移时读到的仍是上一拍的旧值**，导致最后一列数据没被推上去。

---

**现象**：  
波形显示最后一行的末列（如值 `15`）没有进入上一行，窗口生成时缺一列。

---

**原因**：  
非阻塞赋值在同一拍内“先计算右值、最后统一更新”。  
所以上移语句里的 `linebuf[6][i] <= linebuf[7][i];`  
读到的 `linebuf[7][i]` 是**还没被写入最后一列的新值之前的状态**。

---

**两种解决思路**：

1. **推迟上移（推荐）**  
    在行尾只打一个标志，等到**下一行第一列输入时**再执行“上移”。  
    这样 `linebuf[7]` 的数据已经完整更新，读到的就是正确的。  
    ✔ 安全、仿真与综合一致。
    
2. **改用阻塞赋值（权宜之计）**  
    在时序块中用 `=`，让仿真顺序变成“先写后读”，  
    仿真中看起来正确，但硬件并不保证这一执行顺序。  
    ⚠ 风险：仿真与综合行为不一致，后续易出错。
    

---

**总结一句话**：  
你的问题是**非阻塞赋值导致的读旧值**，正确解法是**让上移延后一拍执行**，  
而不是靠阻塞赋值强行改顺序。

**现象**：  
每个 8×8 窗口的最后一个数据错误（比如变成上一行的值 `103`）。

**原因**：  
你在**同一个时钟周期**里同时：

- 用 `<=` 写入当前像素 `linebuf[7][col] <= din`
    
- 又从 `linebuf[7][col]` 里读它来打包窗口  
    非阻塞赋值在硬件里是“先计算右值、统一更新”，所以读到的还是旧的那一拍数据，最后一个点就错。
    

**解决思路**：  
让窗口打包**延后一拍**执行，也就是：

1. 当前拍先把数据写进行缓冲；
    
2. 下一拍再从行缓冲里读数据打包窗口。
    

这样 `linebuf[7][col]` 已经更新完毕，读到的就是正确的新值。

**为什么这样做有效**：  
它遵守硬件的时序逻辑：所有寄存器在时钟上升沿同时更新，而读取应在更新之后。延后一拍的打包保证了数据稳定，不依赖语句顺序，也不会因为仿真和综合语义差异出错。

一句话总结：  
**问题是写和读同拍导致读旧值，解法是打包延后一拍，让数据先落稳再读。**

[TB][1275000] MATCH at win #0
------ GOT window (8x8) ------
  0 1 2 3 4 5 6 7 
  16 17 18 19 20 21 22 23 
  32 33 34 35 36 37 38 39 
  48 49 50 51 52 53 54 55 
  64 65 66 67 68 69 70 71 
  80 81 82 83 84 85 86 87 
  96 97 98 99 100 101 102 103 
  112 113 114 115 116 117 118 119 
------ EXP window (8x8) ------
  0 1 2 3 4 5 6 7 
  16 17 18 19 20 21 22 23 
  32 33 34 35 36 37 38 39 
  48 49 50 51 52 53 54 55 
  64 65 66 67 68 69 70 71 
  80 81 82 83 84 85 86 87 
  96 97 98 99 100 101 102 103 
  112 113 114 115 116 117 118 119 
------------------------------