每拍输入一个像素，按行主序存入
行列计数
 reg [DATAW-1:0] linebuf [0:K-1][0:IMG_W-1];
只保存最近的8行，换行时整体下移
行尾（`col==15`）时**只置位**`roll_pending`；到**下一拍的列0**时（新行第1个像素），先做“上移”，再正常写入这一拍的数据，防止上移和最后一列数据写同时发生，导致最后一列数据无法上移
在 (row,col) ∈ {(7/11/15),(7/11/15)} 时拉高 win_valid 1 拍，并在 win_bus 输出 64 个像素
(row,col)=(15,15) 时给出一拍frame_done



**问题本质**：  
在行缓冲（`linebuf`）中，写入当前行最后一列 (`col=15`) 后立刻执行“整行上移”。  
但因为都是非阻塞赋值 (`<=`)，**上移时读到的仍是上一拍的旧值**，导致最后一列数据没被推上去。

---

**现象**：  
波形显示最后一行的末列（如值 `15`）没有进入上一行，窗口生成时缺一列。

---

**原因**：  
非阻塞赋值在同一拍内“先计算右值、最后统一更新”。  
所以上移语句里的 `linebuf[6][i] <= linebuf[7][i];`  
读到的 `linebuf[7][i]` 是**还没被写入最后一列的新值之前的状态**。

---

**两种解决思路**：

1. **推迟上移（推荐）**  
    在行尾只打一个标志，等到**下一行第一列输入时**再执行“上移”。  
    这样 `linebuf[7]` 的数据已经完整更新，读到的就是正确的。  
    ✔ 安全、仿真与综合一致。
    
2. **改用阻塞赋值（权宜之计）**  
    在时序块中用 `=`，让仿真顺序变成“先写后读”，  
    仿真中看起来正确，但硬件并不保证这一执行顺序。  
    ⚠ 风险：仿真与综合行为不一致，后续易出错。
    

---

**总结一句话**：  
你的问题是**非阻塞赋值导致的读旧值**，正确解法是**让上移延后一拍执行**，  
而不是靠阻塞赋值强行改顺序。

**现象**：  
每个 8×8 窗口的最后一个数据错误（比如变成上一行的值 `103`）。

**原因**：  
你在**同一个时钟周期**里同时：

- 用 `<=` 写入当前像素 `linebuf[7][col] <= din`
    
- 又从 `linebuf[7][col]` 里读它来打包窗口  
    非阻塞赋值在硬件里是“先计算右值、统一更新”，所以读到的还是旧的那一拍数据，最后一个点就错。
    

**解决思路**：  
让窗口打包**延后一拍**执行，也就是：

1. 当前拍先把数据写进行缓冲；
    
2. 下一拍再从行缓冲里读数据打包窗口。
    

这样 `linebuf[7][col]` 已经更新完毕，读到的就是正确的新值。

**为什么这样做有效**：  
它遵守硬件的时序逻辑：所有寄存器在时钟上升沿同时更新，而读取应在更新之后。延后一拍的打包保证了数据稳定，不依赖语句顺序，也不会因为仿真和综合语义差异出错。

一句话总结：  
**问题是写和读同拍导致读旧值，解法是打包延后一拍，让数据先落稳再读。**

[TB][1275000] MATCH at win #0
------ GOT window (8x8) ------
  0 1 2 3 4 5 6 7 
  16 17 18 19 20 21 22 23 
  32 33 34 35 36 37 38 39 
  48 49 50 51 52 53 54 55 
  64 65 66 67 68 69 70 71 
  80 81 82 83 84 85 86 87 
  96 97 98 99 100 101 102 103 
  112 113 114 115 116 117 118 119 
------ EXP window (8x8) ------
  0 1 2 3 4 5 6 7 
  16 17 18 19 20 21 22 23 
  32 33 34 35 36 37 38 39 
  48 49 50 51 52 53 54 55 
  64 65 66 67 68 69 70 71 
  80 81 82 83 84 85 86 87 
  96 97 98 99 100 101 102 103 
  112 113 114 115 116 117 118 119 
------------------------------
![[Pasted image 20251112215117.png]]



**一、背景**  
你在做一个滑动窗口发生器，用于从 16×16 的输入特征图中生成 8×8 的卷积窗口，步长 4。  
输入是按行流入的：每拍来一个像素，先满 16 个再换行。

---

**二、前期问题与改进**

1. **行上移时丢最后一列**
    
    - 原因：在同一拍中写入最后一列 (`linebuf[7][15]`) 的同时上移，  
        非阻塞赋值使得上移时读到的是旧值。
        
    - 解决：将上移操作延后一拍执行（在下一行第一列时再滚动），  
        保证读取的都是更新后的数据。
        
2. **窗口最后一个数据错误**
    
    - 原因：窗口打包时，写入与读取同拍，  
        非阻塞赋值导致 `linebuf[7][col]` 尚未更新，  
        窗口最后一项读到的是旧数据。
        
    - 解决：窗口打包延后一拍执行，  
        或在同拍打包时对当前像素做直通（直接用 `din`）。
        

---

**三、总结逻辑**

- 所有问题的根源都在于**非阻塞赋值的时序特性**：  
    数据更新要等时钟沿之后才能生效，因此“写后立读”会读旧值。
    
- 正确做法是：  
    让“上移”和“打包”都延后一拍执行，保证读取的是稳定的新数据。
    

一句话总结：  
你调通的关键，是把“读”延后，让“写”先落稳。



---

## **Output_regfile 的作用**

在一串按行输入的像素流里，  
**实时生成 8×8 的窗口**（步长 4），给后级池化／卷积计算使用。  
输入是 16×16 的一帧，每拍一个像素。

---

## **核心结构**

1. **8 行行缓冲（linebuf[0..7]）**
    
    - 存最近的 8 行，每行 16 个像素
        
    - `linebuf[7]` 永远是当前正在写的那一行
        
2. **写入机制**
    
    - 每拍写入 `linebuf[7][col]`
        
    - `col==15`（一行结束）时，不立即上移
        
    - **下一行第一个像素到来时**才执行行上移（把 linebuf[1]→0，2→1，…，7→6，然后 row_snap 或 next_line 填进 7）
        
3. **窗口触发条件（win_ready）**
    
    - 当 **行数≥7** 且 **列数≥7**
        
    - 并满足步长对齐：`((row-7)%4==0 && (col-7)%4==0)`
        
    - 但需要排除“正在上移的那一拍”
        
4. **窗口打包（win_bus）**
    
    - 不在同拍打包
        
    - **打包延后一拍**执行，这样能读到稳定的、已经写好的最后一列
        
    - 输出顺序为行优先 `{r0c0, r0c1, …, r7c7}`
        
5. **输出信号**
    
    - `win_valid`：窗口有效 1 拍
        
    - `win_bus`：64 个像素组成的窗口
        
    - `frame_done`：16×16 一帧结束时拉高一拍
        

---

## **关键问题与最终修正**

你遇到的核心 bug 都来自同一件事：

### **非阻塞赋值导致“读写同拍读旧数据”**

- 行上移同拍发生 → 最后一列被上移时读到了旧值
    
- 窗口打包同拍发生 → 最后一项像素读到旧值
    

### **最终解决策略**

- **上移延后一拍执行**
    
- **窗口打包延后一拍执行**
    

这两件事保证所有读取都发生在数据“落稳”之后。

---

## **一句话记住它**

Output_regfile 的本质是：  
**用 8 行行缓冲实时生成 8×8 窗口，所有需要读数据的操作都延后一拍，让写先落稳再读。**

---

如果你想，我还能给你画一张“流程示意图（时序 + 行缓冲变化）”，让你快速复现思路。