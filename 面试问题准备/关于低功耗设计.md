
### 精细化的门控时钟 (Fine-Grained Clock Gating)

**1. 目标与原理**

- **目标**：关闭部分寄存器（Flip-Flops）的时钟，让它们在不需要工作时，不进行任何翻转，从而将这部分电路的动态功耗降到最低。
    
- **核心原理**：动态功耗 `P_dynamic ∝ C * V^2 * f * α`。时钟信号（`f`）是电路中翻转率（`α`）最高的信号。通过直接将时钟 `f` 置为0，可以最有效地消除动态功耗。
    

**2. 如何实现？(为什么不能用简单的与门？)**

你可能会想，用一个与门，将时钟信号clk和使能信号en相与，不就可以了吗？

assign gated_clk = clk & en;

**绝对不能这么做！** 这样做会产生**毛刺（Glitches）**。如果`en`信号在`clk`为高电平期间发生变化，`gated_clk`就会产生危险的毛刺，这可能会导致后级寄存器被错误地触发，造成功能错误。

正确的实现方法是使用**集成门控时钟单元（Integrated Clock Gating Cell, ICG Cell）**。这是一种由芯片代工厂提供的、经过特殊设计的标准单元，它可以保证输出的门控时钟是无毛刺的。

**3. ICG单元的结构与工作方式**

一个典型的ICG单元内部由一个**电平敏感的锁存器（Latch）**和一个**与门（AND Gate）**构成。

- **工作流程**:
    
    1. 当原始时钟`clk`为**低电平**时，内部的锁存器处于“透明”状态。此时，使能信号`en`的值会直接透传过去，更新锁存器的输出`en_latched`。
        
    2. 当原始时钟`clk`变为**高电平**时，锁存器“关闭”，`en_latched`的值被**锁定**，在整个时钟高电平期间保持不变。
        
    3. 最后，被锁定的`en_latched`与原始时钟`clk`进行与操作，产生最终的门控时钟`gated_clk`。
        
- **关键优势**：由于`en_latched`在`clk`的高电平期间是绝对稳定的，所以与门的操作不会产生任何毛刺，保证了`gated_clk`的信号质量。
    

**4. 在RTL代码中如何体现？**

在RTL设计中，我们不需要手动去例化一个ICG单元。现代的综合工具非常智能，只要你写的代码符合特定的**可门控时钟风格**，它就会自动地识别并插入合适的ICG单元。

最常见的风格就是在`always`块的最外层使用`if (enable)`。

Verilog

```
// Verilog code that infers Clock Gating
always @(posedge clk) begin
    if (enable_mac_unit) begin // 综合工具会识别这个if条件
        // 当enable_mac_unit为1时，这些寄存器才需要翻转
        // 工具会自动为这组寄存器生成一个由enable_mac_unit控制的ICG
        pe_output_reg <= pe_output_reg + data_in;
        status_reg <= new_status;
        // ... more registers
    end
end
```

在我的CNN加速器项目中，比如控制整个池化模块的使能信号，或者控制脉动阵列某一行的使能信号，都可以通过这种方式，让综合工具自动地、安全地为我们实现门控时钟，从而在模块或行空闲时节省功耗。

---

### 操作数隔离 (Operand Isolation)

**1. 目标与原理**

- **目标**：当一个**组合逻辑模块**的计算结果不被使用时，锁定它的输入，防止其内部电路因为输入总线的无意义变化而产生不必要的信号翻转。
    
- **核心原理**：同样是降低翻转率`α`。与门控时钟针对寄存器不同，操作数隔离针对的是组合逻辑。即使一个模块的最终输出寄存器被门控时钟了，但如果它前面的组合逻辑（比如一个复杂的乘法器）的输入还在不停变化，这部分组合逻辑仍然会消耗大量的动态功耗。
    

**2. 如何实现？**

实现操作数隔离，最常见的方法就是在组合逻辑的输入端插入**锁存器（Latches）或多路选择器（Multiplexers）**，并由一个使能信号控制。

- **工作流程**：
    
    1. 一个使能信号`use_output_en`（通常和下游寄存器的时钟使能信号是同一个）被用来控制输入端的锁存器。
        
    2. 当`use_output_en`为**高电平**时，表示组合逻辑的结果需要被使用。此时，锁存器变为“透明”，外部的输入信号`A_in`和`B_in`可以无延迟地传递给组合逻辑。
        
    3. 当`use_output_en`为**低电平**时，表示组合逻辑的结果是无效的、被丢弃的。此时，锁存器“关闭”，它会**保持住上一拍的输入值**`A_latched`和`B_latched`。
        
    4. 由于输入被锁定，无论外部的`A_in`和`B_in`如何剧烈变化，组合逻辑内部的电路都不会有任何翻转，从而节省了功耗。
        

**3. 在RTL代码中如何体现？**

操作数隔离也可以由综合工具自动推断出来，但有时也需要设计者更明确地描述这种行为。

Verilog

```
// Verilog code for Operand Isolation
// 假设 'multiplier_output' 是一个很大的组合逻辑
// 'weight' 和 'feature_in' 是不断变化的输入总线
// 'isolated_weight' 和 'isolated_feature' 是隔离后的操作数
reg [7:0] isolated_weight;
reg [7:0] isolated_feature;

// 当乘法器需要工作时，才更新其输入操作数
always @(*) begin
    if (multiplier_enable) begin
        isolated_weight = weight;
        isolated_feature = feature_in;
    end
    // 注意：这里没有else。
    // 在组合逻辑的always块中，不完整的if-else会综合成锁存器（Latch），
    // 恰好可以用来实现操作数隔离。
end

// 耗电大户：乘法器
// 它的输入是隔离后的稳定信号，而不是总线上一直在变的信号
wire [15:0] multiplier_output = isolated_weight * isolated_feature;
```

**总结一下，在我的CNN加速器项目中，这两种技术是协同工作的：**

当我判断某个处理单元（PE）在当前周期不需要工作时，`enable`信号会变为无效。这个`enable`信号会**同时做两件事**：

1. 通过ICG单元，**门控**PE内部所有寄存器的时钟。
    
2. 通过输入端的锁存器，**隔离**PE内部组合逻辑（如乘法器、加法器）的操作数。
    

这样，整个PE模块，无论是时序逻辑还是组合逻辑，都进入了“静态”，实现了功耗节省的最大化。