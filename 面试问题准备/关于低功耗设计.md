
### 精细化的门控时钟 (Fine-Grained Clock Gating)

**1. 目标与原理**

- **目标**：关闭部分寄存器（Flip-Flops）的时钟，让它们在不需要工作时，不进行任何翻转，从而将这部分电路的动态功耗降到最低。
    
- **核心原理**：动态功耗 `P_dynamic ∝ C * V^2 * f * α`。时钟信号（`f`）是电路中翻转率（`α`）最高的信号。通过直接将时钟 `f` 置为0，可以最有效地消除动态功耗。
    

**2. 如何实现？(为什么不能用简单的与门？)**

你可能会想，用一个与门，将时钟信号clk和使能信号en相与，不就可以了吗？

assign gated_clk = clk & en;

**绝对不能这么做！** 这样做会产生**毛刺（Glitches）**。如果`en`信号在`clk`为高电平期间发生变化，`gated_clk`就会产生危险的毛刺，这可能会导致后级寄存器被错误地触发，造成功能错误。

正确的实现方法是使用**集成门控时钟单元（Integrated Clock Gating Cell, ICG Cell）**。这是一种由芯片代工厂提供的、经过特殊设计的标准单元，它可以保证输出的门控时钟是无毛刺的。

**3. ICG单元的结构与工作方式**

一个典型的ICG单元内部由一个**电平敏感的锁存器（Latch）**和一个**与门（AND Gate）**构成。

- **工作流程**:
    
    1. 当原始时钟`clk`为**低电平**时，内部的锁存器处于“透明”状态。此时，使能信号`en`的值会直接透传过去，更新锁存器的输出`en_latched`。
        
    2. 当原始时钟`clk`变为**高电平**时，锁存器“关闭”，`en_latched`的值被**锁定**，在整个时钟高电平期间保持不变。
        
    3. 最后，被锁定的`en_latched`与原始时钟`clk`进行与操作，产生最终的门控时钟`gated_clk`。
        
- **关键优势**：由于`en_latched`在`clk`的高电平期间是绝对稳定的，所以与门的操作不会产生任何毛刺，保证了`gated_clk`的信号质量。
    

**4. 在RTL代码中如何体现？**

在RTL设计中，我们不需要手动去例化一个ICG单元。现代的综合工具非常智能，只要你写的代码符合特定的**可门控时钟风格**，它就会自动地识别并插入合适的ICG单元。

最常见的风格就是在`always`块的最外层使用`if (enable)`。

Verilog

```
// Verilog code that infers Clock Gating
always @(posedge clk) begin
    if (enable_mac_unit) begin // 综合工具会识别这个if条件
        // 当enable_mac_unit为1时，这些寄存器才需要翻转
        // 工具会自动为这组寄存器生成一个由enable_mac_unit控制的ICG
        pe_output_reg <= pe_output_reg + data_in;
        status_reg <= new_status;
        // ... more registers
    end
end
```

在我的CNN加速器项目中，比如控制整个池化模块的使能信号，或者控制脉动阵列某一行的使能信号，都可以通过这种方式，让综合工具自动地、安全地为我们实现门控时钟，从而在模块或行空闲时节省功耗。

---

### 操作数隔离 (Operand Isolation)

**1. 目标与原理**

- **目标**：当一个**组合逻辑模块**的计算结果不被使用时，锁定它的输入，防止其内部电路因为输入总线的无意义变化而产生不必要的信号翻转。
    
- **核心原理**：同样是降低翻转率`α`。与门控时钟针对寄存器不同，操作数隔离针对的是组合逻辑。即使一个模块的最终输出寄存器被门控时钟了，但如果它前面的组合逻辑（比如一个复杂的乘法器）的输入还在不停变化，这部分组合逻辑仍然会消耗大量的动态功耗。
    

**2. 如何实现？**

实现操作数隔离，最常见的方法就是在组合逻辑的输入端插入**锁存器（Latches）或多路选择器（Multiplexers）**，并由一个使能信号控制。

- **工作流程**：
    
    1. 一个使能信号`use_output_en`（通常和下游寄存器的时钟使能信号是同一个）被用来控制输入端的锁存器。
        
    2. 当`use_output_en`为**高电平**时，表示组合逻辑的结果需要被使用。此时，锁存器变为“透明”，外部的输入信号`A_in`和`B_in`可以无延迟地传递给组合逻辑。
        
    3. 当`use_output_en`为**低电平**时，表示组合逻辑的结果是无效的、被丢弃的。此时，锁存器“关闭”，它会**保持住上一拍的输入值**`A_latched`和`B_latched`。
        
    4. 由于输入被锁定，无论外部的`A_in`和`B_in`如何剧烈变化，组合逻辑内部的电路都不会有任何翻转，从而节省了功耗。
        

**3. 在RTL代码中如何体现？**

操作数隔离也可以由综合工具自动推断出来，但有时也需要设计者更明确地描述这种行为。

Verilog

```
// Verilog code for Operand Isolation
// 假设 'multiplier_output' 是一个很大的组合逻辑
// 'weight' 和 'feature_in' 是不断变化的输入总线
// 'isolated_weight' 和 'isolated_feature' 是隔离后的操作数
reg [7:0] isolated_weight;
reg [7:0] isolated_feature;

// 当乘法器需要工作时，才更新其输入操作数
always @(*) begin
    if (multiplier_enable) begin
        isolated_weight = weight;
        isolated_feature = feature_in;
    end
    // 注意：这里没有else。
    // 在组合逻辑的always块中，不完整的if-else会综合成锁存器（Latch），
    // 恰好可以用来实现操作数隔离。
end

// 耗电大户：乘法器
// 它的输入是隔离后的稳定信号，而不是总线上一直在变的信号
wire [15:0] multiplier_output = isolated_weight * isolated_feature;
```

### **总结一下，在我的CNN加速器项目中，这两种技术是协同工作的：**

**当我判断某个处理单元（PE）在当前周期不需要工作时，`enable`信号会变为无效。这个`enable`信号会同时做两件事：**

1. **通过ICG单元，门控PE内部所有寄存器的时钟。**
    
2. **通过输入端的锁存器，隔离PE内部组合逻辑（如乘法器、加法器）的操作数。**
    

**这样，整个PE模块，无论是时序逻辑还是组合逻辑，都进入了“静态”，实现了功耗节省的最大化。**





面试官您好，在我的CNN硬件加速器项目中，实现低功耗是我们设计的核心目标之一，用以解决嵌入式场景下的性能瓶颈 。我们并不是依赖单一技术，而是采用了一套从系统架构到微观实现的多层次、协同的低功耗设计策略。

主要可以分为以下三个层面：

第一，在系统架构层面，核心思想是“减少高功耗的数据搬运”。

我们知道，在芯片中，数据移动、特别是片外DDR的访问，是功耗最大的操作之一。我的设计通过一个三级存储架构来最大化地减少这种高功耗访问 。

- **DDR-BRAM-Register File架构**：我们将整个神经网络的权重和大量的特征图存放在低速但容量大的DDR中，但计算核心（脉动阵列）几乎不直接与DDR交互。
    
- **Ping-Pong BRAM缓存**：我们使用片上BRAM作为高速缓存，通过Ping-Pong操作，让计算单元在处理A区数据时，DMA控制器在后台将下一批数据从DDR搬运至B区，反之亦然 。这掩盖了DDR的延迟，保证了计算核心永远在处理片上数据，极大地降低了访问DDR的频次和功耗。
    
- **寄存器级数据复用**：在脉动阵列的每个处理单元（PE）内部，我们设计了寄存器文件（Register File）来实现数据的极致复用 。例如，一个权重加载进PE的寄存器后，可以与一整行或一整列的输入数据进行运算，无需反复从BRAM读取，这进一步减少了片上存储的访问功耗。
    

第二，在微架构（RTL实现）层面，核心思想是“减少无效的翻转功耗”。

动态功耗与时钟频率、电压以及电路的翻转率成正比。在电压和频率确定后，降低翻转率是关键。

- **精细化的门控时钟（Clock Gating）**：这是最直接有效的手段。我的设计中，整个加速器被划分为多个功能模块，如卷积引擎、池化单元、控制器等。当某个模块空闲时，比如在执行全连接层时，卷积和池化单元的时钟会被自动关闭，从而消除这部分电路的动态功耗。这种门控可以做到非常精细，甚至在脉动阵列中，如果某几行暂时没有计算任务，也可以被门控。
    
- **操作数隔离（Operand Isolation）**：当一个计算单元（比如一个乘加器）的结果不被使用时，我们会通过使能信号锁存其输入。这样即使输入总线上的数据在变化，计算单元内部的组合逻辑也不会产生任何翻转，避免了无意义的功耗。
    
- **定制化的计算单元**：简历中提到，我设计了优化的8x8有符号乘加器，相比综合器默认生成的乘法器，面积节省了约20% 5。更小的面积通常意味着更短的连线和更小的内部电容，这直接降低了每一次乘加运算所消耗的动态功耗。
    

第三，在数据层面，核心思想是“降低数据表示的比特宽度”。

这也是我们能做到低功耗的一个根本性原因。

- **8-bit整数量化（INT8 PTQ）**：我们将模型从原始的32位浮点数，通过训练后量化（PTQ）技术转换为了8位定点整数 6。这个操作带来的功耗收益是巨大的：
    
    1. **存储和带宽减半**：数据位宽减少了75%，无论是DDR、BRAM还是寄存器，存储相同数量的参数功耗都大大降低，数据搬运的功耗也同比例下降。
        
    2. **计算功耗降低**：一个8位的乘法器，其面积和功耗远小于一个32位的浮点乘法器。整个16x8的脉动阵列 7 因为采用了8位计算单元，其整体功耗相比32位实现呈数量级的下降。
        

**总结一下**，我的低功耗设计是一个系统性工程：通过**量化**从源头减少了数据量，通过**优化的存储架构**减少了高代价的数据搬运，再通过**门控时钟和操作数隔离等RTL技巧**精细地关闭了空闲单元的功耗。这三者结合，才最终实现了低功耗的目标。

