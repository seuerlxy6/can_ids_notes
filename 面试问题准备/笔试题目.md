## 1、真值表、卡诺图
![[Pasted image 20250730173810.png]]
### (1) 真值表（把 B C＝11 的两行标成 “X” 表示 don’t‑care）

|A|B|C|说明 (B·C)|Z = A B‾\overline{B} + A‾\overline{A}B‾\overline{B}C + A‾\overline{A}BC‾\overline{C}|
|---|---|---|---|---|
|0|0|0|0|0|
|0|0|1|0|1|
|0|1|0|0|1|
|0|1|1|**1 → X**|X|
|1|0|0|0|1|
|1|0|1|0|1|
|1|1|0|0|0|
|1|1|1|**1 → X**|X|

BC＝11 的组合（表中两行）在题目条件下不会出现，可当作 don’t‑care，用 “X” 留给后续卡诺图化简。

**(2) 三变量 K‑map**（A 做行，BC 做列，列序 Gray：00 01 11 10；X 为 “BC = 11” 的 don’t‑care）

| A\BC  | 00  | 01  | 11  | 10  |
| ----- | --- | --- | --- | --- |
| **0** | 0   | 1   | X   | 1   |
| **1** | 1   | 1   | X   | 0   |

- ① 列 01 + 11（C = 1）四格并成一组 → **C**
    
- ② 行 A = 1 且 B = 0（列 00+01）两格 → **A \overline{B}**
    
- ③ 行 A = 0 且 B = 1（列 10+11）两格 → **\overline{A} B**
    

---

**(3) 最简结果**

Z=C+AB‾+A‾BZ = C + A\overline{B} + \overline{A}B

再压一口气：AB‾+A‾B=A⊕BA\overline{B} + \overline{A}B = A \oplus B，所以

**Z=C  +  (A⊕B)**\boxed{Z = C \;+\; (A \oplus B)}

对所有合法输入（BC≠11）与原式一致，多出的输出只落在“非法”组合上，不影响系统行为。

在 Gray 顺序排布的卡诺图里，**最左列和最右列视为“相邻”**，同一行上的这两格可以当成一块来圈；上下边也一样。原则不变：

- 只能圈 2n2^n 个 1／X（一格、两格、四格……）。
    
- 必须全部是 1（或 X），中间不能掺 0。
    
- 把环绕得到的块按“留不变变量”规则写项即可。
    

所以第 4 列（BC = 10）如果和第 1 列（BC = 00）里同一行都为 1，就能横向合并成一个 2‑格块；化简时那一行里 **C 变了、B 不变**，留下对应的 A/B。

![[Pasted image 20250730174504.png]]
## 3、![[Pasted image 20250817173456.png]]
`Y = A * 11111011`，其中 `A` 是一个8位输入 `A[7:0]`
1111011取反加1=5，是-5
A * 5 = (A * 4) + (A * 1)
`A * 4` 在硬件中等价于将 `A` **左移两位** (`A << 2`)。
`A * 1` 就是 `A` 本身。
 因此，`A * 5` 可以通过 `(A << 2) + A` 实现。这只需要一个移位器（在硬件中只是布线，不消耗逻辑资源）和一个加法器。
module（
input signed[7:0]A,
output signed[15:0]B
);

assign B = -(（A<<2)+A);

endmodule
## 4、如何衡量验证的完备性？
