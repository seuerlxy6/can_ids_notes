## 1、真值表、卡诺图
![[Pasted image 20250730173810.png]]
### (1) 真值表（把 B C＝11 的两行标成 “X” 表示 don’t‑care）

|A|B|C|说明 (B·C)|Z = A B‾\overline{B} + A‾\overline{A}B‾\overline{B}C + A‾\overline{A}BC‾\overline{C}|
|---|---|---|---|---|
|0|0|0|0|0|
|0|0|1|0|1|
|0|1|0|0|1|
|0|1|1|**1 → X**|X|
|1|0|0|0|1|
|1|0|1|0|1|
|1|1|0|0|0|
|1|1|1|**1 → X**|X|

BC＝11 的组合（表中两行）在题目条件下不会出现，可当作 don’t‑care，用 “X” 留给后续卡诺图化简。

**(2) 三变量 K‑map**（A 做行，BC 做列，列序 Gray：00 01 11 10；X 为 “BC = 11” 的 don’t‑care）

| A\BC  | 00  | 01  | 11  | 10  |
| ----- | --- | --- | --- | --- |
| **0** | 0   | 1   | X   | 1   |
| **1** | 1   | 1   | X   | 0   |

- ① 列 01 + 11（C = 1）四格并成一组 → **C**
    
- ② 行 A = 1 且 B = 0（列 00+01）两格 → **A \overline{B}**
    
- ③ 行 A = 0 且 B = 1（列 10+11）两格 → **\overline{A} B**
    

---

**(3) 最简结果**

Z=C+AB‾+A‾BZ = C + A\overline{B} + \overline{A}B

再压一口气：AB‾+A‾B=A⊕BA\overline{B} + \overline{A}B = A \oplus B，所以

**Z=C  +  (A⊕B)**\boxed{Z = C \;+\; (A \oplus B)}

对所有合法输入（BC≠11）与原式一致，多出的输出只落在“非法”组合上，不影响系统行为。

在 Gray 顺序排布的卡诺图里，**最左列和最右列视为“相邻”**，同一行上的这两格可以当成一块来圈；上下边也一样。原则不变：

- 只能圈 2n2^n 个 1／X（一格、两格、四格……）。
    
- 必须全部是 1（或 X），中间不能掺 0。
    
- 把环绕得到的块按“留不变变量”规则写项即可。
    

所以第 4 列（BC = 10）如果和第 1 列（BC = 00）里同一行都为 1，就能横向合并成一个 2‑格块；化简时那一行里 **C 变了、B 不变**，留下对应的 A/B。

![[Pasted image 20250730174504.png]]
## 3、![[Pasted image 20250817173456.png]]
`Y = A * 11111011`，其中 `A` 是一个8位输入 `A[7:0]`
1111011取反加1=5，是-5
A * 5 = (A * 4) + (A * 1)
`A * 4` 在硬件中等价于将 `A` **左移两位** (`A << 2`)。
`A * 1` 就是 `A` 本身。
 因此，`A * 5` 可以通过 `(A << 2) + A` 实现。这只需要一个移位器（在硬件中只是布线，不消耗逻辑资源）和一个加法器。
module（
input signed[7:0]A,
output signed[15:0]B
);

assign B = -(（A<<2)+A);

endmodule
## 4、如何衡量验证的完备性？

这是一个经典的有限状态机（FSM）设计问题，要求使用Moore型状态机来完成。

### 1) 状态转移图

设计思路:

Moore状态机的输出只与当前状态有关。为了检测序列“1101”，我们需要定义一系列状态来记住当前已经匹配了序列的多少部分。

- **S0 (初始状态)**: 未检测到任何有效序列的开始。输出为`0`。
    
- **S1**: 已检测到序列的第一个`1`。输出为`0`。
    
- **S2**: 已检测到序列`11`。输出为`0`。
    
- **S3**: 已检测到序列`110`。输出为`0`。
    
- **S4**: 已检测到完整序列`1101`。**在此状态下，输出为`1`**。
    

**状态转移逻辑分析:**

- **从 S0 (输出=0) 开始:**
    
    - 如果输入为`0`，不满足序列开头，继续停在`S0`。
        
    - 如果输入为`1`，可能是序列的开始，转移到`S1`。
        
- **在 S1 (已检测到"1", 输出=0):**
    
    - 如果输入为`0`，序列匹配中断（得到"10"），回到`S0`。
        
    - 如果输入为`1`，序列匹配继续（得到"11"），转移到`S2`。
        
- **在 S2 (已检测到"11", 输出=0):**
    
    - 如果输入为`0`，序列匹配继续（得到"110"），转移到`S3`。
        
    - 如果输入为`1`，序列匹配为"111"。由于题目要求的是不重叠检测，我们可以认为最后两个"11"是下一个可能序列的开头，所以继续停留在`S2`。
        
- **在 S3 (已检测到"110", 输出=0):**
    
    - 如果输入为`0`，序列匹配中断（得到"1100"），回到`S0`。
        
    - 如果输入为`1`，序列匹配完成（得到"1101"），转移到`S4`。
        
- **在 S4 (已检测到"1101", 输出=1):**
    
    - 这是我们的目标状态，输出为`1`。
        
    - **因为是不重叠检测**，状态机在下一个时钟周期必须离开此状态。
        
    - 如果下一个输入为`0`，不构成新序列的开头，回到`S0`。
        
    - 如果下一个输入为`1`，这个`1`可以是新序列的开头，转移到`S1`。
        

**状态转移图如下:**

（图中 `状态/输出` 的格式表示在该状态下的输出值）

---

### 2) 如何衡量验证的完备性？

衡量一个设计验证的“完备性”或“完整性”，意味着我们需要通过一系列量化指标来判断测试是否充分，是否覆盖了设计的所有功能和极端情况。对于这个状态机设计，我们可以从以下几个关键维度来衡量：

**核心思想**：验证的完备性由**覆盖率（Coverage）**来衡量。目标是达到100%的覆盖率。

**1. 状态机覆盖率 (FSM Coverage)**

这是针对状态机设计最直接、最重要的衡量标准。

- **状态覆盖率 (State Coverage)**: 确保在仿真测试过程中，**所有的状态 (S0, S1, S2, S3, S4) 都至少被进入过一次**。如果某个状态从未被达到，说明测试激励不足或者设计中存在无法到达的冗余状态。
    
- **状态转移覆盖率 (Arc/Transition Coverage)**: 更加严格的标准。它要求**每一个可能的状态转移路径都至少被执行过一次**。例如，不仅要确保S2被访问过，还要确保`S1->S2`，`S2->S2`，`S2->S3`这三条转移路径都被触发过。100%的状态转移覆盖率是验证状态机逻辑完整性的基本要求。
    

**2. 功能覆盖率 (Functional Coverage)**

功能覆盖率衡量的是我们是否把设计规格（SPEC）中要求的所有功能点都测试到了。它不关心代码是怎么写的，只关心功能。

- **关键场景覆盖**: 我们需要定义一系列必须被测试到的场景（Cover Points），并通过仿真来“收集”这些场景是否发生。
    
    - **成功检测场景**: 输入一个完整的`1101`序列，并检查输出是否在正确的时间点变为`1`。例如，测试序列 `...0011010...`。
        
    - **“差一点”失败场景**: 测试那些几乎要成功但最终失败的序列，确保状态机能正确返回。例如：
        
        - `...01100...` (在最后一步失败)
            
        - `...01110...` (在中间步骤失败)
            
    - **背靠背成功场景**: 测试连续的、不重叠的`1101`序列能否被正确检测两次。例如 `...110101101...`。
        
    - **重叠输入场景**: 根据“不重叠”的定义，测试输入`1101101`，检查是否只在第一个`1101`后输出`1`，并且状态機能正确地开始检测下一个序列。
        
    - **复位场景**: 在状态机运行到任意状态（如S2, S3）时，测试复位信号是否能强制其立即回到初始状态`S0`。
        

**3. 代码覆盖率 (Code Coverage)**

这是衡量RTL代码本身被测试程度的指标，是验证完备性的基础。

- **行覆盖率 (Line Coverage)**: RTL代码中的每一行是否都至少被执行过一次。
    
- **分支/条件覆盖率 (Branch/Conditional Coverage)**: 代码中所有的`if-else`、`case`语句的每一个分支是否都被执行到。例如，在描述状态转移的`case`语句中，`S0`到`S4`的每一个`case`项都应被覆盖。
    
- **翻转覆盖率 (Toggle Coverage)**: 设计中每一个信号（或reg/wire的每一位）是否都经历了从`0`到`1`和从`1`到`0`的变化。
    

**总结**

要全面衡量这个状态机设计的验证完备性，需要结合以上三种覆盖率：

1. **基础是100%的代码覆盖率**，确保没有未经测试的代码逻辑。
    
2. **核心是100%的状态机覆盖率**（特别是状态转移覆盖率），确保状态机的每一个逻辑路径都经过了验证。
    
3. **最终目标是100%的功能覆盖率**，通过它来证明设计完全符合预期的所有功能场景和规格要求。

5、![[Pasted image 20250818204145.png]]
